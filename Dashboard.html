<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light" />
  <title>Scope Dashboard</title>
  <link rel="icon" type="image/svg+xml" href="assets/logo.svg" />
  <script>
    (function(){
      if(!window.DASHBOARD_API_BASE){
        const explicit = document.documentElement?.getAttribute('data-api-base') || document.body?.getAttribute('data-api-base');
        if(explicit){
          window.DASHBOARD_API_BASE = explicit;
        }else{
          const host = (typeof window !== 'undefined' && window.location) ? window.location.hostname : '';
          const isLocal = ['localhost','127.0.0.1','0.0.0.0','::1'].includes(host);
          if(isLocal){
            window.DASHBOARD_API_BASE = 'http://localhost:8888';
          }else if (typeof window !== 'undefined' && window.location && window.location.origin){
            window.DASHBOARD_API_BASE = window.location.origin;
          }else{
            window.DASHBOARD_API_BASE = 'https://din-side.netlify.app';
          }
        }
      }
    })();
  </script>
  <style>
    :root{
      color-scheme:light;
      --bg-from:#f6f7fb;
      --bg-to:#edf1f8;
      --surface:#ffffff;
      --surface-muted:rgba(255,255,255,0.9);
      --surface-elevated:#fafbff;
      --surface-glass:rgba(255,255,255,0.85);
      --surface-ghost:rgba(247,249,254,0.75);
      --primary:#5d63ff;
      --primary-hover:#4b52e0;
      --primary-pressed:#3f45c6;
      --primary-border:rgba(93,99,255,0.3);
      --accent-positive:#12b67a;
      --accent-negative:#f05454;
      --accent-neutral:#7c8fac;
      --highlight-bg:linear-gradient(140deg,#ffffff 0%,#f5f7fb 100%);
      --highlight-border:rgba(15,23,42,0.08);
      --highlight-shadow:0 24px 55px rgba(15,23,42,0.12);
      --highlight-shadow-hover:0 32px 68px rgba(15,23,42,0.16);
      --highlight-border-hover:rgba(93,99,255,0.28);
      --text:#0F172A;
      --text-strong:#0F172A;
      --text-muted:#4b5566;
      --text-soft:#7b879c;
      --text-inverse:#F8FAFC;
      --border:#E2E8F0;
      --border-subtle:rgba(148,163,184,0.35);
      --shadow-xs:0 10px 26px rgba(15,23,42,0.08);
      --shadow-sm:0 16px 32px rgba(15,23,42,0.12);
      --shadow-md:0 24px 48px rgba(15,23,42,0.16);
      --shadow-lg:0 40px 80px rgba(15,23,42,0.18);
      --ring:0 0 0 3px rgba(93,99,255,0.32);
      --ring-offset:0 0 0 5px rgba(255,255,255,0.85);
      --chart-grid:rgba(15,23,42,0.08);
      --chart-grid-strong:rgba(15,23,42,0.12);
      --chart-panel-top:#eef3fb;
      --chart-panel-bottom:#dfe7f5;
      --radius-sm:0.75rem;
      --radius-md:1rem;
      --radius-lg:1.5rem;
      --radius-pill:999px;
      --space-1:0.5rem;
      --space-2:0.75rem;
      --space-3:1rem;
      --space-4:1.5rem;
      --space-5:2rem;
      --transition:180ms ease;
    }
    body[data-theme="dark"]{
      color-scheme:dark;
      --bg-from:#0b1020;
      --bg-to:#0b1222;
      --surface:#0f172a;
      --surface-muted:rgba(15,23,42,0.8);
      --surface-elevated:#111c32;
      --surface-glass:rgba(15,23,42,0.82);
      --surface-ghost:rgba(15,23,42,0.65);
      --accent-positive:#00f4c5;
      --accent-negative:#f97070;
      --accent-neutral:#a0a8c0;
      --highlight-bg:linear-gradient(145deg,#141821,#1b1f29);
      --highlight-border:rgba(255,255,255,0.08);
      --highlight-shadow:0 18px 44px rgba(0,0,0,0.55);
      --highlight-shadow-hover:0 32px 64px rgba(0,0,0,0.65);
      --highlight-border-hover:rgba(255,255,255,0.14);
      --text:#E2E8F0;
      --text-strong:#F8FAFC;
      --text-muted:#94A3B8;
      --text-soft:#7C8FAC;
      --text-inverse:#0F172A;
      --border:#1f2937;
      --border-subtle:rgba(30,41,59,0.68);
      --shadow-xs:0 10px 26px rgba(2,6,23,0.42);
      --shadow-sm:0 18px 36px rgba(2,6,23,0.48);
      --shadow-md:0 24px 54px rgba(2,6,23,0.6);
      --shadow-lg:0 32px 80px rgba(2,6,23,0.66);
      --ring-offset:0 0 0 4px rgba(15,23,42,0.85);
      --chart-grid:rgba(255,255,255,0.12);
      --chart-grid-strong:rgba(255,255,255,0.18);
      --chart-panel-top:#132238;
      --chart-panel-bottom:#0b111f;
    }
    *,*::before,*::after{box-sizing:border-box;}
    html{background:var(--bg-from);}
    body{
      margin:0;
      min-height:100vh;
      font-family:"Inter","SF Pro Text",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      line-height:1.6;
      letter-spacing:0.01em;
      color:var(--text);
      background:var(--bg-from);
      position:relative;
      transition:color var(--transition),background var(--transition);
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      background:
        radial-gradient(900px 900px at 0% -5%,rgba(108,99,255,0.16),transparent 60%),
        radial-gradient(720px 720px at 95% -10%,rgba(90,83,230,0.14),transparent 65%),
        linear-gradient(180deg,var(--bg-from) 0%,var(--bg-to) 100%);
    }
    body[data-theme="dark"]::before{
      background:
        radial-gradient(880px 880px at 0% -10%,rgba(108,99,255,0.24),transparent 65%),
        radial-gradient(680px 680px at 95% -10%,rgba(76,72,180,0.2),transparent 70%),
        linear-gradient(180deg,var(--bg-from) 0%,var(--bg-to) 100%);
    }
    @media (prefers-reduced-motion:reduce){
      *,*::before,*::after{transition:none!important;animation:none!important;}
    }
    ::selection{background:rgba(108,99,255,0.25);}
    a{color:inherit;text-decoration:none;}
    a:hover{color:var(--primary);}
    img{max-width:100%;display:block;}
    h1,h2,h3,h4{margin:0;color:var(--text-strong);font-weight:600;}
    p{margin:0;color:var(--text);}
    p.muted{color:var(--text-muted);}
    ul{margin:0;padding:0;list-style:none;}
    table{border-collapse:separate;border-spacing:0;width:100%;}
    thead th{font-weight:600;color:var(--text-muted);font-size:0.85rem;text-transform:uppercase;letter-spacing:0.08em;padding-bottom:var(--space-2);}
    tbody td{padding:0.5rem 0;color:var(--text);font-size:0.95rem;border-top:1px solid var(--border);}
    tbody tr:first-child td{border-top:none;}
    button,input,select,label{font:inherit;color:inherit;}
    button{background:none;border:none;padding:0;cursor:pointer;}
    button:disabled{cursor:not-allowed;opacity:0.6;}
    button:focus-visible,[role="button"]:focus-visible,input:focus-visible,select:focus-visible{outline:none;box-shadow:var(--ring);}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;}
    .shell{width:100%;max-width:1160px;margin:0 auto;padding-inline:clamp(16px,4vw,56px);}
    main.shell{padding-block:clamp(24px,4vw,56px);}
    .top-bar{
      position:sticky;
      top:0;
      z-index:30;
      background:var(--surface-glass);
      backdrop-filter:saturate(160%) blur(14px);
      border-bottom:1px solid var(--border-subtle);
      box-shadow:0 10px 30px rgba(15,23,42,0.08);
      transition:transform var(--transition),opacity var(--transition),background var(--transition);
    }
    body[data-theme="dark"] .top-bar{
      background:var(--surface-glass);
      box-shadow:0 14px 36px rgba(2,6,23,0.5);
    }
    .top-bar[data-hidden="1"]{transform:translateY(-110%);opacity:0;}
    .top-bar__inner{
      display:flex;
      align-items:center;
      gap:var(--space-3);
      min-height:4.25rem;
      font-family:"Inter","SF Pro Text",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      position:relative;
    }
    .brand{
      display:inline-flex;
      align-items:center;
      justify-content:flex-start;
      font-weight:700;
      font-size:clamp(1.25rem,3vw,1.65rem);
      letter-spacing:0.04em;
      color:var(--primary);
      text-transform:capitalize;
    }
    .brand-title{
      flex:1;
      text-align:center;
      font-size:clamp(1rem,2.2vw,1.25rem);
      font-weight:600;
      color:var(--text-strong);
      position:absolute;
      left:50%;
      transform:translateX(-50%);
    }
    .nav-actions{
      display:flex;
      align-items:center;
      gap:var(--space-2);
      margin-left:auto;
      position:relative;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:0.35rem;
      padding:0.35rem 0.95rem;
      min-height:2.5rem;
      border-radius:var(--radius-pill);
      border:1px solid var(--border);
      background:var(--surface);
      color:var(--text);
      font-size:0.92rem;
      font-weight:600;
      letter-spacing:0.01em;
      box-shadow:var(--shadow-xs);
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition),transform var(--transition);
    }
    .chip:hover{background:color-mix(in srgb,var(--surface) 82%,var(--primary) 18%);color:var(--text-strong);border-color:var(--primary);transform:translateY(-1px);}
    .chip[aria-pressed="true"]{
      background:var(--primary);
      border-color:var(--primary);
      color:var(--text-inverse);
      box-shadow:0 16px 34px rgba(108,99,255,0.26);
    }
    .chip[aria-pressed="true"]:hover{background:var(--primary-hover);}
    .chip:active{background:var(--primary-pressed);color:var(--text-inverse);}
    .chip:focus-visible{box-shadow:var(--ring);}
    .user-menu{position:relative;}
    .user-menu__trigger{
      width:2.75rem;
      height:2.75rem;
      padding:0;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--surface);
      box-shadow:var(--shadow-xs);
    }
    .user-menu__trigger:hover{background:color-mix(in srgb,var(--surface) 88%,var(--primary) 12%);}
    .user-menu__icon{display:flex;flex-direction:column;align-items:center;justify-content:center;gap:4px;}
    .user-menu__icon span{display:block;width:18px;height:2px;border-radius:999px;background:var(--text);transition:background var(--transition);}
    .user-menu.open .user-menu__icon span{background:var(--primary);}
    .user-menu__panel{
      position:absolute;
      top:calc(100% + 12px);
      right:0;
      min-width:220px;
      background:var(--surface-elevated);
      border:1px solid var(--border);
      border-radius:var(--radius-md);
      box-shadow:var(--shadow-lg);
      padding:var(--space-1) 0;
      opacity:0;
      visibility:hidden;
      transform:translateY(-8px);
      transition:opacity var(--transition),transform var(--transition),visibility var(--transition);
      z-index:40;
    }
    .user-menu.open .user-menu__panel{opacity:1;visibility:visible;transform:translateY(0);}
    .user-menu__item{
      width:100%;
      padding:0.65rem var(--space-3);
      display:flex;
      align-items:center;
      gap:0.65rem;
      font-size:0.92rem;
      background:none;
      border:none;
      color:var(--text);
      text-align:left;
      transition:background var(--transition),color var(--transition);
    }
    .user-menu__item svg{
      width:18px;
      height:18px;
      flex:0 0 18px;
    }
    .user-menu__item:hover,
    .user-menu__item:focus-visible{background:color-mix(in srgb,var(--surface) 86%,var(--primary) 14%);color:var(--text-strong);outline:none;}
    .user-menu__item--danger{color:#ff4d4f;}
    .mobile-toggle{
      display:none;
      align-items:center;
      gap:0.45rem;
      padding:0.4rem 0.95rem;
      border-radius:var(--radius-pill);
      border:1px solid var(--border);
      background:var(--surface);
      color:var(--text-strong);
      font-weight:600;
      font-size:0.9rem;
      box-shadow:var(--shadow-xs);
      transition:background var(--transition),border-color var(--transition),color var(--transition);
    }
    .mobile-toggle .dots{display:flex;flex-direction:column;gap:3px;}
    .mobile-toggle .dots span{width:16px;height:2px;border-radius:999px;background:currentColor;}
    .mobile-toggle:hover{background:color-mix(in srgb,var(--surface) 86%,var(--primary) 14%);color:var(--text-strong);border-color:var(--primary);}
    .nav-controls{
      display:inline-flex;
      align-items:center;
      gap:var(--space-2);
      padding:0.35rem;
      border-radius:var(--radius-pill);
      border:1px solid var(--border);
      background:var(--surface-muted);
      box-shadow:var(--shadow-xs);
    }
    .nav-controls.open{display:flex;}
    .segmented-control{
      display:inline-flex;
      align-items:center;
      gap:0.3rem;
      padding:0.25rem;
      border-radius:var(--radius-pill);
      background:var(--surface);
      border:1px solid var(--border);
      box-shadow:var(--shadow-xs);
    }
    .segmented-control__option{
      min-height:2.1rem;
      padding:0.25rem 0.9rem;
      border-radius:var(--radius-pill);
      border:1px solid transparent;
      background:transparent;
      color:var(--text-muted);
      font-size:0.85rem;
      font-weight:600;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    .segmented-control__option[aria-pressed="true"]{
      background:var(--primary);
      border-color:var(--primary);
      color:var(--text-inverse);
      box-shadow:0 10px 24px rgba(108,99,255,0.28);
    }
    .segmented-control__option:hover{color:var(--text-strong);}
    .segmented-control__option:focus-visible{box-shadow:var(--ring);}
    .theme-switch{
      position:relative;
      display:inline-flex;
      width:54px;
      height:30px;
      border-radius:var(--radius-pill);
      border:1px solid var(--border);
      background:var(--surface);
      box-shadow:var(--shadow-xs);
    }
    .theme-switch input{opacity:0;width:0;height:0;position:absolute;}
    .theme-switch .slider{
      position:absolute;
      inset:0;
      border-radius:inherit;
      background:linear-gradient(120deg,rgba(108,99,255,0.16),rgba(108,99,255,0.05));
      transition:background var(--transition),border-color var(--transition);
      padding:4px;
      display:block;
    }
    .theme-switch .thumb{
      position:absolute;
      top:50%;
      left:4px;
      width:22px;
      height:22px;
      border-radius:50%;
      background:var(--surface);
      border:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:center;
      transform:translateY(-50%);
      transition:transform var(--transition),background var(--transition),border-color var(--transition),color var(--transition);
      box-shadow:var(--shadow-xs);
      color:#FDB813;
    }
    .theme-switch .icon{width:16px;height:16px;}
    .theme-switch .icon.moon{display:none;color:#f8fafc;}
    .theme-switch input:checked + .slider .thumb{
      left:calc(100% - 26px);
      color:#f1f5f9;
      border-color:var(--primary-border);
      background:var(--primary);
    }
    .theme-switch input:checked + .slider{background:linear-gradient(120deg,rgba(93,84,230,0.32),rgba(76,71,204,0.18));}
    .theme-switch input:checked + .slider .icon.sun{display:none;}
    .theme-switch input:checked + .slider .icon.moon{display:block;}
    .theme-switch input:focus-visible + .slider,
    .theme-switch .thumb:focus-visible{box-shadow:var(--ring);}
    nav.sub-nav{
      padding-block-start:clamp(12px,2.4vw,20px);
      padding-block-end:clamp(6px,1.6vw,12px);
      border-bottom:1px solid transparent;
      background:transparent;
    }
    .sub-nav__inner{
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:1rem;
      width:100%;
    }
    .sub-nav__inner .tablist{
      grid-column:2;
      justify-self:center;
    }
    .sub-nav__inner .tablist-date{
      grid-column:3;
      justify-self:end;
    }
    .sub-nav__filters{
      grid-column:1/-1;
      width:100%;
      display:flex;
      justify-content:flex-start;
      margin-top:clamp(10px,1.8vw,18px);
    }
    body[data-active-tab] [data-toolbar-for]{display:none;}
    body[data-active-tab="kpi"] [data-toolbar-for="kpi"]{display:flex;}
    .tablist{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:0.4rem;
      padding:0.4rem;
      border:1px solid var(--border);
      border-radius:calc(var(--radius-pill) + 8px);
      background:color-mix(in srgb,var(--surface) 78%,transparent);
      box-shadow:var(--shadow-xs);
      width:fit-content;
      max-width:100%;
      margin-inline:auto;
      overflow-x:auto;
    }
    .tablist-date{
      display:flex;
      align-items:center;
      justify-content:center;
      white-space:nowrap;
      gap:0.5rem;
    }
    .tablist-date__today{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:0.35rem 0.85rem;
      border-radius:var(--radius-pill);
      border:1px solid var(--border);
      background:color-mix(in srgb,var(--surface) 88%,transparent);
      color:var(--text);
      font-weight:700;
      font-size:0.88rem;
      box-shadow:var(--shadow-xs);
      cursor:pointer;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    body[data-theme="dark"] .tablist-date__today{
      background:rgba(15,23,42,0.65);
      color:var(--text);
      border-color:var(--border-subtle);
    }
    .tablist-date__today:hover{color:var(--text-strong);border-color:var(--primary);background:color-mix(in srgb,var(--surface) 84%,var(--primary) 16%);}
    .tablist-date__today:focus-visible{outline:none;box-shadow:var(--ring);}
    .tablist-date__today[disabled]{opacity:0.65;cursor:default;color:var(--text-muted);border-color:var(--border);}
    .tablist-date__today--active{border-color:var(--primary-border);background:color-mix(in srgb,var(--primary) 15%,var(--surface) 85%);color:var(--text-strong);}
    body[data-theme="dark"] .tablist-date__today--active{background:color-mix(in srgb,var(--primary) 12%,rgba(15,23,42,0.85) 88%);}
    .tablist-date__trigger{
      display:inline-flex;
      align-items:center;
      gap:0.45rem;
      border-radius:var(--radius-pill);
      border:1px solid var(--border);
      background:color-mix(in srgb,var(--surface) 85%,transparent);
      color:var(--text-strong);
      font-size:0.9rem;
      font-weight:600;
      padding:0.35rem 0.9rem;
      box-shadow:var(--shadow-xs);
    }
    body[data-theme="dark"] .tablist-date__trigger{
      background:rgba(15,23,42,0.65);
      color:var(--text);
      border-color:var(--border-subtle);
    }
    .tablist-date__trigger:hover{color:var(--primary);}
    .tablist-date__trigger:focus-visible{box-shadow:var(--ring);}
    .tablist-date__icon{
      width:1rem;
      height:1rem;
      opacity:0.75;
    }
    .tablist-date__input{pointer-events:none;}
    .tab-button{
      min-height:2.6rem;
      padding:0.5rem 1.3rem;
      border-radius:var(--radius-pill);
      border:1px solid transparent;
      background:transparent;
      color:var(--text-muted);
      font-size:0.95rem;
      font-weight:600;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition),transform var(--transition);
    }
    .tab-button:hover{color:var(--text-strong);}
    .tab-button.active,
    .tab-button[aria-selected="true"]{
      background:var(--primary);
      color:var(--text-inverse);
      border-color:var(--primary);
      box-shadow:0 16px 32px rgba(108,99,255,0.28);
    }
    .tab-button:focus-visible{box-shadow:var(--ring);}
    .tab-panel{
      display:flex;
      flex-direction:column;
      gap:clamp(24px,4vw,36px);
    }
    .tab-panel[hidden]{display:none;}
    .tab-panel> *{width:100%;}
    .card{
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:var(--radius-lg);
      box-shadow:var(--shadow-sm);
      padding:clamp(1.5rem,2.8vw,2rem);
      transition:box-shadow var(--transition),transform var(--transition),background var(--transition);
    }
    .card:hover{transform:translateY(-2px);box-shadow:var(--shadow-md);}
    .card header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:var(--space-2);
      margin-bottom:var(--space-3);
    }
    .card header h2{
      font-size:1.1rem;
      font-weight:600;
      color:var(--text-strong);
    }
    .card header .subtle{
      font-size:0.9rem;
      color:var(--text-muted);
    }
    .stats-grid{
      display:grid;
      gap:var(--space-3);
      grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
    }
    .chart-stats{
      display:grid;
      gap:var(--space-3);
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      align-items:stretch;
      width:100%;
    }
    .chart-stat-card{
      padding:var(--space-4);
      display:flex;
      flex-direction:column;
      gap:0.6rem;
    }
    .chart-stat-card__header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:var(--space-2);
      flex-wrap:wrap;
    }
    .chart-stat-card__title{
      margin:0;
      font-size:1.12rem;
      font-weight:700;
      color:var(--text-strong);
      flex:1;
    }
    .chart-stat-card__body{
      display:flex;
      flex-direction:column;
      gap:var(--space-3);
    }
    .chart-stat-card--metric{gap:0.4rem;padding:var(--space-3);}
    .chart-stat-card--metric .chart-stat-card__value{font-size:clamp(1.5rem,2.6vw,2rem);}
    .chart-stat-card--metric .chart-stat-card__status{margin:0;font-size:0.82rem;color:var(--text-muted);} 
    .chart-stat-card--metric .chart-stat-card__status[data-tone="error"]{color:#ef4444;}
    .chart-stat-card--metric .chart-stat-card__status[data-tone="warning"]{color:#fbbf24;}
    .chart-stat-card__eyebrow{
      font-size:0.82rem;
      letter-spacing:0.12em;
      text-transform:uppercase;
      color:var(--text-muted);
      font-weight:600;
    }
    .chart-stat-card__value{
      font-size:clamp(1.8rem,3vw,2.4rem);
      font-weight:700;
      color:var(--text-strong);
      margin:0;
      transition:color var(--transition);
    }
    .chart-stat-card__value.negative{color:#ef4444;}
    .chart-stat-card__value.positive{color:#16a34a;}
    .chart-stat-card__status{
      margin:0;
      font-size:0.9rem;
      color:var(--text-muted);
    }
    .chart-stat-card__status[data-tone="error"]{color:#f87171;}
    .stat{padding:var(--space-4);}
    .stat h2{font-size:1rem;color:var(--text-muted);font-weight:600;}
    .stat-number{
      font-size:2rem;
      font-weight:700;
      color:var(--text-strong);
      margin-top:0.35rem;
      letter-spacing:-0.01em;
    }
    .stat-sub{
      color:var(--text-muted);
      margin-top:0.35rem;
      font-size:0.95rem;
    }
    .table-card table{font-size:0.95rem;}
    .table-scroll{overflow:auto;max-height:360px;padding-bottom:0.5rem;}
    .table-scroll::-webkit-scrollbar{height:8px;width:8px;}
    .table-scroll::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.4);border-radius:999px;}
    .chart-card .bar-chart{
      position:relative;
      min-height:260px;
      border-radius:var(--radius-md);
      border:1px dashed var(--border-subtle);
      background:color-mix(in srgb,var(--surface) 90%,transparent);
      display:flex;
      align-items:flex-end;
      justify-content:space-evenly;
      gap:0.8rem;
      overflow-x:auto;
      padding:var(--space-4);
    }
    .chart-card .bar-chart[data-empty="1"]{
      align-items:center;
      justify-content:center;
      gap:0;
    }
    .chart-card .bar-chart::-webkit-scrollbar{height:8px;}
    .chart-card .bar-chart::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.35);border-radius:999px;}
    .bar{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:0.6rem;
      min-width:4.4rem;
      flex:1 1 4.4rem;
      --bar-index:0;
    }
    .bar__column{
      position:relative;
      width:100%;
      height:var(--track-height,240px);
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding:0.35rem 0.35rem;
      border-radius:28px;
      border:0;
      background:transparent;
      transition:transform 160ms ease;
      cursor:pointer;
    }
    .bar__column::after{
      content:"";
      position:relative;
      display:block;
      width:100%;
      height:var(--fill-height,22px);
      border-radius:22px;
      background:linear-gradient(180deg,var(--primary) 0%,var(--primary-hover) 100%);
      transition:height 200ms ease,transform 160ms ease;
    }
    .bar__column[data-zero="1"]::after{
      background:rgba(148,163,184,0.55);
      height:12px;
    }
    .bar__column[data-tone="best"]::after{
      background:linear-gradient(180deg,#34d399 0%,#059669 100%);
    }
    .bar__column[data-tone="worst"]::after{
      background:linear-gradient(180deg,#fda4af 0%,#ef4444 100%);
    }
    .bar__column:hover,
    .bar__column:focus-visible{
      transform:translateY(-6px);
      outline:none;
    }
    .bar__column:hover::after,
    .bar__column:focus-visible::after{
      transform:translateY(-6px);
    }
    .bar__label{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:0.14rem;
      font-size:0.74rem;
      text-transform:uppercase;
      letter-spacing:0.08em;
      color:var(--text-muted);
    }
    .bar__label strong{font-size:0.78rem;color:var(--text-strong);}
    .bar__label small{font-size:0.7rem;color:var(--text-muted);}
    .tripletex-grid{
      display:grid;
      gap:var(--space-3);
      grid-template-columns:repeat(auto-fit,minmax(320px,1fr));
    }
    .range-placeholder{
      display:flex;
      flex-direction:column;
      gap:var(--space-2);
      background:var(--surface);
      border:1px dashed var(--border);
      border-radius:var(--radius-lg);
      box-shadow:var(--shadow-sm);
      padding:clamp(1.5rem,2.8vw,2rem);
    }
    .range-placeholder h2{
      margin:0;
      font-size:1.05rem;
      color:var(--text-strong);
    }
    .range-placeholder p{
      margin:0;
      color:var(--text-muted);
    }
    [data-range-hidden="1"]{
      display:none !important;
    }
    .reports-toolbar{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      justify-content:flex-start;
      gap:clamp(12px,1.8vw,20px);
      margin:clamp(4px,1vw,16px) 0 var(--space-2);
      width:100%;
      max-width:720px;
      position:relative;
    }
    .reports-toolbar[data-toolbar-mode="simple"] .reports-filter[data-open]{
      width:min(100%,228px);
      padding:var(--space-2) var(--space-2) var(--space-1);
    }
    .reports-toolbar[data-toolbar-mode="simple"] .reports-filter[data-open][data-range-panel="month"]{
      width:min(100%,92px);
      padding:var(--space-2) var(--space-2) var(--space-1);
    }
    .reports-toolbar[data-toolbar-mode="simple"] .reports-filter[data-open][data-range-panel="week"]{
      width:min(100%,100px);
      padding:var(--space-2) var(--space-2) var(--space-1);
    }
    .reports-toolbar[data-toolbar-mode="simple"] .reports-filter[data-open]::before{
      content:"";
      position:absolute;
      top:-10px;
      left:16px;
      width:12px;
      height:12px;
      background:inherit;
      border-left:1px solid var(--border);
      border-top:1px solid var(--border);
      transform:rotate(45deg);
      z-index:-1;
    }
    .reports-range{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap:clamp(0.4rem,1vw,0.85rem);
      flex-wrap:nowrap;
      overflow-x:auto;
      scrollbar-width:none;
      -ms-overflow-style:none;
      padding-bottom:0.15rem;
    }
    .reports-range::-webkit-scrollbar{display:none;}
    @media (max-width:640px){
      .reports-range{
        flex-wrap:wrap;
        overflow:visible;
        padding-bottom:0;
      }
    }
    .reports-range__label{
      display:inline-flex;
      align-items:baseline;
      gap:0.4rem;
      white-space:nowrap;
      margin-left:clamp(0.8rem,1.6vw,1.25rem);
      flex:0 0 auto;
    }
    .reports-range__title{
      font-size:clamp(1.3rem,3.4vw,1.9rem);
      font-weight:700;
      color:#0f172a;
      letter-spacing:0.01em;
      white-space:nowrap;
    }
    body[data-theme="dark"] .reports-range__title{
      color:var(--text-strong);
    }
    .reports-range__month{
      font-size:clamp(1.3rem,3.4vw,1.9rem);
      font-weight:700;
      color:var(--primary);
      letter-spacing:0.01em;
      white-space:nowrap;
    }
    .reports-range__btn{
      padding:0.5rem 1rem;
      border-radius:999px;
      border:1px solid var(--border-subtle);
      background:color-mix(in srgb,var(--surface) 96%,transparent);
      font-weight:600;
      font-size:0.95rem;
      cursor:pointer;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition),transform var(--transition);
    }
    .reports-range__btn:active{transform:translateY(1px);}
    .reports-range__btn.active,
    .reports-range__btn[data-selected="true"]{
      background:var(--primary);
      color:var(--text-inverse);
      border-color:var(--primary);
      box-shadow:0 8px 18px rgba(108,99,255,0.24);
    }
    .reports-range__btn:focus-visible{outline:none;box-shadow:var(--ring);}
    .reports-range__btn:not(.active):hover{border-color:var(--primary);color:var(--primary-hover);}
    .reports-filter{
      display:flex;
      flex-direction:column;
      gap:var(--space-1);
      width:100%;
      max-width:100%;
      align-items:flex-start;
    }
    .reports-filter[hidden]{display:none !important;}
    .reports-filter[data-open]{
      position:absolute;
      top:calc(100% + var(--space-1));
      left:0;
      background:var(--surface-elevated);
      border:1px solid var(--border);
      border-radius:var(--radius-lg);
      padding:var(--space-3);
      box-shadow:var(--shadow-lg);
      width:min(100%,360px);
      z-index:50;
      gap:var(--space-2);
    }
    .reports-filter[data-open][data-range-panel="month"]{
      width:min(100%,105px);
    }
    .reports-filter[data-open][data-range-panel="week"]{
      width:min(100%,320px);
    }
    .reports-filter[data-open][data-range-panel="day"]{
      width:min(100%,340px);
    }
    .reports-month-grid,
    .reports-week-grid{
      display:flex;
      align-items:center;
      gap:var(--space-1);
      flex-wrap:nowrap;
      overflow-x:auto;
      padding-bottom:0.35rem;
      margin-bottom:-0.35rem;
      width:100%;
      scrollbar-width:thin;
      scroll-snap-type:x proximity;
      -webkit-overflow-scrolling:touch;
    }
    .reports-filter[data-open] .reports-month-grid,
    .reports-filter[data-open] .reports-week-grid{
      display:flex;
      flex-direction:column;
      gap:var(--space-1);
      max-height:240px;
      padding-right:0.4rem;
      overflow-y:auto;
      overflow-x:hidden;
      flex-wrap:nowrap;
      scroll-snap-type:none;
    }
    .reports-filter[data-open] .reports-month-grid{
      scrollbar-width:none;
      -ms-overflow-style:none;
    }
    .reports-filter[data-open] .reports-month-grid::-webkit-scrollbar{
      display:none;
    }
    .reports-filter[data-open] .reports-week-grid{
      scrollbar-width:none;
      -ms-overflow-style:none;
    }
    .reports-filter[data-open] .reports-week-grid::-webkit-scrollbar{
      display:none;
    }
    .reports-filter[data-open] .reports-day-grid{
      display:flex;
      flex-direction:column;
      gap:var(--space-1);
      max-height:280px;
      padding-right:0.25rem;
      overflow-y:auto;
      overflow-x:hidden;
    }
    .reports-month{
      padding:0.4rem 0.65rem;
      border-radius:var(--radius-sm);
      border:1px solid var(--border-subtle);
      background:color-mix(in srgb,var(--surface) 95%,transparent);
      font-weight:600;
      font-size:0.84rem;
      cursor:pointer;
      scroll-snap-align:start;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    .reports-month[data-active="true"],
    .reports-month.selected,
    .reports-week[data-active="true"]{
      background:color-mix(in srgb,var(--primary) 20%,var(--surface) 80%);
      color:var(--text-strong);
      border-color:var(--primary);
      box-shadow:0 6px 18px rgba(0,0,0,0.16);
    }
    .reports-month[data-available="true"]:not([data-active="true"]),
    .reports-week[data-available="true"]:not([data-active="true"]){
      border-color:var(--border);
      color:var(--text-muted);
      background:color-mix(in srgb,var(--surface) 96%,transparent);
    }
    .reports-month:hover,
    .reports-week:hover{border-color:var(--primary);}
    .reports-week{
      padding:0.35rem 0.5rem;
      border-radius:var(--radius-sm);
      border:1px solid var(--border-subtle);
      background:color-mix(in srgb,var(--surface) 95%,transparent);
      font-weight:600;
      font-size:0.82rem;
      cursor:pointer;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    .reports-day{
      padding:0.45rem 0.6rem;
      border-radius:var(--radius-md);
      border:1px solid var(--border-subtle);
      background:color-mix(in srgb,var(--surface) 95%,transparent);
      font-weight:600;
      font-size:0.85rem;
      cursor:pointer;
      display:flex;
      justify-content:space-between;
      align-items:center;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    .reports-day[data-active="true"]{
      background:color-mix(in srgb,var(--primary) 20%,var(--surface) 80%);
      color:var(--text-strong);
      border-color:var(--primary);
      box-shadow:0 6px 18px rgba(0,0,0,0.16);
    }
    .reports-day:hover{border-color:var(--primary);}
    .reports-day small{
      font-weight:500;
      color:var(--text-muted);
    }
    .reports-day-controls{
      display:flex;
      gap:var(--space-1);
      width:100%;
      align-items:center;
    }
    .reports-day-input{
      flex:1;
      padding:0.45rem 0.6rem;
      border-radius:var(--radius-sm);
      border:1px solid var(--border-subtle);
      background:color-mix(in srgb,var(--surface) 95%,transparent);
      color:var(--text);
    }
    .reports-day-today{
      padding:0.45rem 0.75rem;
      border-radius:var(--radius-sm);
      border:1px solid var(--border);
      background:color-mix(in srgb,var(--surface) 90%,transparent);
      font-weight:600;
      cursor:pointer;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    .reports-day-today:hover{border-color:var(--primary);color:var(--primary-hover);}
    .reports-hint{font-size:0.9rem;color:var(--text-muted);} 
    .tripletex-card h2{font-size:1.05rem;}
    .tripletex-status{font-size:0.85rem;color:var(--text-muted);margin:0;}
    .tripletex-status[data-tone="error"]{color:#dc2626;}
    .tripletex-status[data-tone="muted"]{color:var(--text-muted);}
    .tripletex-table{width:100%;border-collapse:separate;border-spacing:0;font-size:0.9rem;font-variant-numeric:tabular-nums;}
    .tripletex-table thead th{padding-bottom:0.6rem;color:var(--text-muted);font-weight:600;text-transform:uppercase;font-size:0.78rem;letter-spacing:0.08em;border-bottom:1px solid var(--border);text-align:left;}
    .tripletex-table tbody td{padding:0.7rem 0;border-bottom:1px solid var(--border-subtle);}
    .tripletex-table tbody tr:last-child td{border-bottom:none;}
    .tripletex-table .numeric{text-align:right;}
    .tripletex-table .trend-positive{color:#16a34a;}
    .tripletex-table .trend-negative{color:#dc2626;}
    .tripletex-table .muted{color:var(--text-muted);}
    .chart-nav{
      display:flex;
      align-items:center;
      gap:0.5rem;
    }
    .chart-nav__btn{
      width:2.4rem;
      height:2.4rem;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--surface);
      color:var(--text);
      box-shadow:var(--shadow-xs);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:1.2rem;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    .chart-nav__btn:hover{background:color-mix(in srgb,var(--surface) 85%,var(--primary) 15%);border-color:var(--primary);}
    .chart-card header{
      display:flex;
      flex-wrap:wrap;
      align-items:flex-start;
      justify-content:space-between;
      gap:0.75rem 1rem;
    }
    .chart-card header h2{
      margin:0;
    }
    .chart-header__main{
      display:flex;
      flex-direction:column;
      gap:0.5rem;
    }
    .chart-week-heading{
      margin:0;
      font-size:1.25rem;
      font-weight:700;
      color:var(--text-strong);
    }
    .chart-meta{
      display:flex;
      flex-wrap:wrap;
      gap:0.45rem 1.2rem;
      font-size:0.85rem;
      color:var(--text-muted);
    }
    .chart-meta__total,
    .chart-meta__average{
      font-weight:600;
      color:var(--text-strong);
    }
    .bar-chart--slide-next .bar,
    .bar-chart--slide-prev .bar{
      animation-duration:280ms;
      animation-timing-function:cubic-bezier(0.22,0.61,0.36,1);
      animation-fill-mode:both;
      animation-delay:calc(var(--bar-index) * 26ms);
    }
    .bar-chart--slide-next .bar{animation-name:chart-slide-next;}
    .bar-chart--slide-prev .bar{animation-name:chart-slide-prev;}
    @keyframes chart-slide-next{
      from{opacity:0;transform:translateX(14%);}
      to{opacity:1;transform:translateX(0);}
    }
    @keyframes chart-slide-prev{
      from{opacity:0;transform:translateX(-14%);}
      to{opacity:1;transform:translateX(0);}
    }
    .chart-tooltip{
      position:absolute;
      transform:translate(-50%,calc(-100% - 18px));
      background:color-mix(in srgb,var(--surface) 94%,rgba(15,23,42,0.85));
      color:var(--text-strong);
      border:1px solid var(--border);
      border-radius:var(--radius-sm);
      padding:0.6rem 0.9rem;
      box-shadow:0 18px 36px rgba(15,23,42,0.32);
      font-size:0.85rem;
      pointer-events:none;
      min-width:150px;
      text-align:left;
      opacity:0;
      transition:opacity 140ms ease,transform 140ms ease;
    }
    .chart-tooltip[data-visible="1"]{opacity:1;}
    .chart-tooltip strong{display:block;font-size:0.88rem;margin-bottom:0.15rem;}
    .chart-tooltip span{font-size:0.88rem;display:block;}
    .chart-stat-card__controls,
    .daily-summary__controls{display:flex;align-items:center;gap:0.5rem;justify-content:flex-end;flex-shrink:0;}
    .chart-stat-card__input,
    .daily-summary__input{
      appearance:none;
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:var(--radius-sm);
      padding:0.45rem 0.75rem;
      font-size:0.95rem;
      color:var(--text);
      box-shadow:var(--shadow-xs);
      transition:border-color var(--transition),box-shadow var(--transition);
    }
    .chart-stat-card__input:focus-visible,
    .daily-summary__input:focus-visible{border-color:var(--primary);box-shadow:var(--ring);}
    .summary-card{
      background:color-mix(in srgb,var(--surface) 82%,rgba(108,99,255,0.06));
      border:1px solid var(--border);
      border-radius:var(--radius-md);
      padding:var(--space-3);
      box-shadow:var(--shadow-xs);
      display:flex;
      flex-direction:column;
      gap:0.4rem;
    }
    .summary-card__label{color:var(--text-muted);font-size:0.9rem;font-weight:500;}
    .summary-card__value{font-size:1.4rem;font-weight:700;color:var(--text-strong);}
    .summary-card__value.fade{color:var(--text-muted);}
    .summary-card__meta{font-size:0.85rem;color:var(--text-muted);}
    .overview-highlights{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
      gap:clamp(16px,3vw,28px);
      margin-bottom:clamp(16px,3vw,32px);
    }
    .overview-highlights + .overview-highlights{margin-top:clamp(16px,2vw,28px);}
    .overview-highlight{
      background:var(--highlight-bg);
      border:1px solid var(--highlight-border);
      border-radius:16px;
      padding:clamp(20px,3vw,28px);
      min-height:160px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:0.5rem;
      text-align:center;
      box-shadow:var(--highlight-shadow);
      backdrop-filter:blur(14px);
      transition:transform 160ms ease,box-shadow 160ms ease,border-color 160ms ease;
    }
    .overview-highlight:hover{
      transform:translateY(-4px);
      box-shadow:var(--highlight-shadow-hover);
      border-color:var(--highlight-border-hover);
    }
    .overview-highlight__eyebrow{
      font-size:0.78rem;
      text-transform:uppercase;
      letter-spacing:0.22em;
      color:var(--text-muted);
    }
    .overview-highlight__value{
      font-size:2.1rem;
      font-weight:700;
      color:var(--text-strong);
      font-variant-numeric:tabular-nums;
      font-feature-settings:"tnum";
    }
    .overview-highlight__value.positive{color:var(--accent-positive);}
    .overview-highlight__value.negative{color:var(--accent-negative);}
    .overview-highlight__meta{
      font-size:0.9rem;
      color:var(--text-muted);
    }
    .overview-highlight__badge{
      font-size:0.8rem;
      font-weight:600;
      color:var(--accent-positive);
    }
    .overview-highlight__badge.trend-negative{color:var(--accent-negative);}
    .overview-highlight__pill{
      display:inline-flex;
      align-items:center;
      gap:0.4rem;
      font-size:0.82rem;
      background:var(--surface-ghost);
      border:1px solid var(--border-subtle);
      border-radius:999px;
      padding:0.25rem 0.75rem;
      width:fit-content;
      color:var(--text);
    }
    .ai-hourly-card{
      position:relative;
      overflow:hidden;
      border-radius:30px;
      padding:clamp(1.8rem,4vw,3rem);
      border:1px solid var(--highlight-border);
      background:var(--highlight-bg);
      box-shadow:var(--highlight-shadow);
      backdrop-filter:blur(30px);
      isolation:isolate;
      transition:transform var(--transition),box-shadow var(--transition),border-color var(--transition);
    }
    .ai-hourly-card:hover{
      transform:translateY(-6px);
      border-color:var(--highlight-border-hover);
      box-shadow:var(--highlight-shadow-hover);
    }
    .ai-hourly-card::before,
    .ai-hourly-card::after{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      pointer-events:none;
      z-index:0;
    }
    .ai-hourly-card::before{
      background:linear-gradient(180deg,rgba(255,255,255,0.05),transparent 55%);
      mix-blend-mode:screen;
      opacity:0.4;
    }
    .ai-hourly-card::after{
      background:
        radial-gradient(circle at 0% 90%,rgba(0,0,0,0.16),transparent 60%),
        radial-gradient(circle at 100% 0%,rgba(255,255,255,0.03),transparent 55%);
      opacity:0.35;
    }
    body[data-theme="dark"] .ai-hourly-card{
      background:linear-gradient(135deg,#0a101d 0%,#111b2f 60%,#090f1b 100%);
      border:1px solid rgba(255,255,255,0.08);
      box-shadow:0 45px 120px rgba(4,9,20,0.8);
    }
    body[data-theme="dark"] .ai-hourly-card::after{
      background:
        radial-gradient(circle at 0% 100%,rgba(0,0,0,0.45),transparent 55%),
        radial-gradient(circle at 100% 0%,rgba(255,255,255,0.05),transparent 55%);
      opacity:0.5;
    }
    .ai-hourly-card>*{position:relative;z-index:1;}
    .ai-hourly-card__header{
      display:flex;
      justify-content:space-between;
      gap:var(--space-3);
      flex-wrap:wrap;
      align-items:flex-start;
    }
    .ai-hourly-card__eyebrow{
      display:inline-flex;
      align-items:center;
      padding:0.25rem 0.9rem;
      border-radius:999px;
      font-size:0.75rem;
      text-transform:uppercase;
      letter-spacing:0.13em;
      background:var(--surface-ghost);
      border:1px solid var(--border-subtle);
      color:var(--text-muted);
      margin-bottom:0.6rem;
    }
    .ai-hourly-card__header h2{
      font-size:1.3rem;
      letter-spacing:0.08em;
      color:var(--text-strong);
      text-transform:uppercase;
    }
    .ai-hourly-card__sub{
      color:var(--text-muted);
      margin-top:0.3rem;
      font-size:0.92rem;
    }
    .ai-hourly-card__meta{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:0.65rem;
      min-width:190px;
    }
    .ai-hourly-card__tag{
      padding:0.3rem 1rem;
      border-radius:999px;
      font-size:0.8rem;
      font-weight:600;
      letter-spacing:0.05em;
      background:var(--surface-ghost);
      border:1px solid var(--border-subtle);
      color:var(--text);
      box-shadow:0 8px 26px rgba(3,10,18,0.15);
    }
    body[data-theme="dark"] .ai-hourly-card__tag{
      background:rgba(0,10,20,0.65);
      border:1px solid rgba(255,255,255,0.2);
      color:#e1fdfb;
      box-shadow:0 8px 26px rgba(3,10,18,0.55);
    }
    .ai-hourly-card__legend{
      display:flex;
      gap:1.2rem;
      flex-wrap:wrap;
      font-size:0.86rem;
      color:var(--text);
    }
    .ai-hourly-card__legend span{
      display:inline-flex;
      align-items:center;
      gap:0.38rem;
      font-weight:500;
    }
    .ai-hourly-card__dot{
      width:0.55rem;
      height:0.55rem;
      border-radius:999px;
    }
    .ai-hourly-card__dot--current{
      background:#4fa7ff;
      box-shadow:0 0 12px rgba(79,167,255,0.4);
    }
    .ai-hourly-card__dot--previous{
      background:rgba(120,126,148,0.5);
    }
    .ai-hourly-card__chart{
      margin-top:var(--space-3);
      position:relative;
      border-radius:22px;
      overflow:hidden;
    }
    .ai-hourly-card__chart canvas{
      width:100%;
      height:280px;
      display:block;
    }
    .ai-hourly-card__empty{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:600;
      color:rgba(255,255,255,0.82);
      backdrop-filter:blur(12px);
      background:rgba(8,11,20,0.65);
    }
    .ai-hourly-card__footer{
      margin-top:var(--space-3);
      display:flex;
      flex-direction:column;
      gap:1.2rem;
    }
    .ai-hourly-card__stats{
      display:grid;
      grid-template-columns:minmax(180px,1.3fr) repeat(2,minmax(140px,0.9fr)) auto;
      gap:1.3rem;
      align-items:center;
      padding:1.1rem 1.4rem;
      border-radius:20px;
      border:1px solid var(--border-subtle);
      background:var(--surface);
      box-shadow:var(--shadow-xs);
    }
    body[data-theme="dark"] .ai-hourly-card__stats{
      background:rgba(15,23,42,0.5);
      border:1px solid rgba(255,255,255,0.08);
      box-shadow:none;
    }
    .ai-hourly-card__stat{
      display:flex;
      flex-direction:column;
      gap:0.25rem;
    }
    .ai-hourly-card__stat-label{
      font-size:0.78rem;
      text-transform:uppercase;
      letter-spacing:0.18em;
      color:var(--text-muted);
    }
    .ai-hourly-card__focus-label{
      font-weight:600;
      color:var(--text-strong);
      letter-spacing:0.04em;
    }
    .ai-hourly-card__stat-value{
      font-size:1.4rem;
      color:var(--text-strong);
      font-weight:700;
      font-variant-numeric:tabular-nums;
      font-feature-settings:"tnum";
    }
    .ai-hourly-card__pill{
      justify-self:flex-end;
      padding:0.45rem 1.1rem;
      border-radius:999px;
      background:linear-gradient(120deg,rgba(18,182,122,0.18),rgba(0,201,147,0.4));
      color:#0c5138;
      border:1px solid rgba(18,182,122,0.4);
      font-weight:600;
      font-size:0.92rem;
      text-align:center;
      min-width:120px;
      box-shadow:0 12px 35px rgba(18,182,122,0.28);
    }
    body[data-theme="dark"] .ai-hourly-card__pill{
      color:#c5ffe8;
      background:linear-gradient(120deg,rgba(16,141,101,0.3),rgba(0,255,173,0.45));
      border:1px solid rgba(0,255,173,0.45);
      box-shadow:0 12px 35px rgba(7,217,158,0.3);
    }
    @media (max-width:900px){
      .ai-hourly-card__stats{
        grid-template-columns:repeat(auto-fit,minmax(160px,1fr));
      }
      .ai-hourly-card__pill{justify-self:flex-start;}
      .ai-hourly-card__note{text-align:left;}
    }
    .ai-hourly-card__note{
      color:var(--text-muted);
      font-size:0.92rem;
      text-align:right;
    }
    .ai-hourly-card[data-tone="positive"] .ai-hourly-card__tag{
      background:rgba(16,88,65,0.55);
      border-color:rgba(0,255,173,0.35);
      color:#7fffd6;
    }
    .ai-hourly-card[data-tone="positive"] .ai-hourly-card__pill{
      background:linear-gradient(120deg,rgba(16,141,101,0.3),rgba(0,255,173,0.45));
      color:#c5ffe8;
      border-color:rgba(0,255,173,0.65);
    }
    .ai-hourly-card[data-tone="negative"] .ai-hourly-card__tag{
      background:rgba(93,20,28,0.55);
      border-color:rgba(255,107,122,0.4);
      color:#ffc2c2;
    }
    .ai-hourly-card[data-tone="negative"] .ai-hourly-card__pill{
      background:linear-gradient(120deg,rgba(255,122,122,0.25),rgba(255,66,66,0.4));
      color:#ffe1e1;
      border-color:rgba(255,120,120,0.55);
    }
    .ai-insights-card .ai-insights{
      display:grid;
      gap:var(--space-3);
      grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
    }
    .ai-insights__column h3{font-size:0.95rem;font-weight:600;color:var(--text-muted);}
    .ai-insights__list{
      display:flex;
      flex-direction:column;
      gap:0.75rem;
      margin-top:var(--space-2);
    }
    .ai-section-header{display:flex;align-items:center;justify-content:space-between;gap:var(--space-2);flex-wrap:wrap;margin-bottom:var(--space-3);}
    .ai-section-header__meta{display:flex;align-items:center;gap:var(--space-2);flex-wrap:wrap;}
    .ai-section-header__today{
      padding:0.45rem 0.9rem;
      border-radius:var(--radius-pill);
      border:1px solid var(--border);
      background:color-mix(in srgb,var(--surface) 90%,transparent);
      color:var(--text);
      font-weight:600;
      cursor:pointer;
      transition:background var(--transition),color var(--transition),border-color var(--transition),box-shadow var(--transition);
    }
    .ai-section-header__today:hover{background:color-mix(in srgb,var(--surface) 80%,var(--primary-hover) 20%);border-color:var(--primary);color:var(--text-strong);}
    .ai-section-header__today:focus-visible{outline:none;box-shadow:var(--ring);}
    .ai-insights__list:empty{
      border:1px dashed var(--border);
      border-radius:var(--radius-md);
      padding:1rem;
      align-items:center;
      justify-content:center;
      min-height:4.5rem;
      display:flex;
    }
    .ai-insights__list:empty::before{
      content:"Ingen data for valgt dato.";
      color:var(--text-muted);
      font-size:0.9rem;
    }
    .ai-insights__item{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:0.75rem;
      padding:0.7rem 0.9rem;
      border-radius:var(--radius-md);
      border:1px solid var(--border);
      background:color-mix(in srgb,var(--surface) 82%,rgba(108,99,255,0.05));
      box-shadow:var(--shadow-xs);
      font-size:0.92rem;
    }
    .ai-insights__product{font-weight:600;color:var(--text-strong);}
    .ai-insights__metric{color:var(--text-muted);font-size:0.9rem;}
    .ai-insights__status{
      margin-top:var(--space-3);
      font-size:0.92rem;
      color:var(--text-muted);
      display:flex;
      align-items:center;
      gap:0.5rem;
    }
    .ai-insights__status::before{
      content:"";
      width:0.75rem;
      height:0.75rem;
      border-radius:50%;
      background:var(--border);
      flex-shrink:0;
    }
    .ai-insights__status[data-tone="error"]{color:#f87171;}
    .ai-insights__status[data-tone="info"]{color:var(--primary);}
    .ai-insights__status[data-tone="demo"]{color:var(--primary);}
    .ai-insights__status:empty{display:none;}
    .ai-insights__status[data-tone="error"]::before{background:#f87171;}
    .ai-insights__status[data-tone="info"]::before{background:var(--primary);}
    .ai-insights__status[data-tone="demo"]::before{background:var(--primary);}
    .revenue-card,.product-change-card{
      display:flex;
      flex-direction:column;
      gap:var(--space-3);
    }
    .revenue-card__grid{
      display:grid;
      gap:var(--space-3);
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
    }
    .revenue-card__stat{
      border:1px solid var(--border);
      border-radius:var(--radius-md);
      padding:var(--space-3);
      background:color-mix(in srgb,var(--surface) 82%,rgba(108,99,255,0.05));
      box-shadow:var(--shadow-xs);
      display:flex;
      flex-direction:column;
      gap:0.4rem;
    }
    .revenue-card__label{font-size:0.85rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.06em;}
    .revenue-card__value{font-size:1.35rem;font-weight:700;color:var(--text-strong);}
    .revenue-card__delta{font-size:0.9rem;color:var(--text-muted);}
    .revenue-card__delta[data-tone="up"]{color:#22c55e;}
    .revenue-card__delta[data-tone="down"]{color:#f87171;}
    .revenue-card__note{
      font-size:0.92rem;
      color:var(--text-muted);
      display:flex;
      align-items:center;
      gap:0.5rem;
    }
    .revenue-card__note:empty{display:none;}
    .revenue-card__note::before,
    .product-change-card__status::before,
    .day-status::before{
      content:"";
      width:0.65rem;
      height:0.65rem;
      border-radius:50%;
      background:var(--border);
      flex-shrink:0;
    }
    .revenue-card__note[data-tone="error"]::before,
    .product-change-card__status[data-tone="error"]::before,
    .day-status[data-tone="error"]::before{background:#f87171;}
    .revenue-card__note[data-tone="positive"]::before,
    .product-change-card__status[data-tone="positive"]::before,
    .day-status[data-tone="positive"]::before{background:#22c55e;}
    .revenue-card__note[data-tone="warning"]::before,
    .product-change-card__status[data-tone="warning"]::before,
    .day-status[data-tone="warning"]::before{background:#fbbf24;}
    .product-change-card__columns{
      display:grid;
      gap:var(--space-3);
      grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
    }
    .product-change-card__column h3{font-size:0.95rem;font-weight:600;color:var(--text-muted);}
    .product-change-card__list{
      display:flex;
      flex-direction:column;
      gap:0.75rem;
      margin-top:var(--space-2);
    }
    .product-change-card__list:empty{
      border:1px dashed var(--border);
      border-radius:var(--radius-md);
      padding:1rem;
      align-items:center;
      justify-content:center;
      min-height:4.5rem;
      display:flex;
    }
    .product-change-card__list:empty::before{
      content:"Ingen data for valgt dato.";
      color:var(--text-muted);
      font-size:0.9rem;
    }
    .product-change-card__item{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:0.75rem;
      padding:0.7rem 0.9rem;
      border-radius:var(--radius-md);
      border:1px solid var(--border);
      background:color-mix(in srgb,var(--surface) 82%,rgba(108,99,255,0.05));
      box-shadow:var(--shadow-xs);
      font-size:0.92rem;
    }
    .product-change-card__name{
      font-weight:600;
      color:var(--text-strong);
      flex:1;
      min-width:0;
    }
    .product-change-card__metrics{
      font-size:0.9rem;
      color:var(--text-muted);
      text-align:right;
      white-space:nowrap;
    }
    .product-change-card__item[data-tone="up"] .product-change-card__metrics{color:#22c55e;}
    .product-change-card__item[data-tone="down"] .product-change-card__metrics{color:#f87171;}
    .product-change-card__status{
      font-size:0.92rem;
      color:var(--text-muted);
      display:flex;
      align-items:center;
      gap:0.5rem;
    }
    .product-change-card__status:empty{display:none;}
    .day-status{
      margin-top:var(--space-2);
      font-size:0.9rem;
      color:var(--text-muted);
    }
    .day-status:empty{display:none;}
    .day-status[data-tone="muted"]{color:var(--text-muted);}
    .day-status[data-tone="warning"]{color:#fbbf24;}
    .day-status[data-tone="error"]{color:#f87171;}
    .day-status[data-tone="positive"]{color:#22c55e;}
    .bar-chart__empty{
      font-size:0.95rem;
      color:var(--text-muted);
    }
    @media (max-width:900px){
      .brand-title{text-align:left;position:static;transform:none;left:auto;}
      .nav-actions{gap:var(--space-1);}
    }
    @media (max-width:720px){
      .top-bar__inner{flex-wrap:wrap;justify-content:space-between;}
      .brand-title{order:3;width:100%;text-align:left;position:static;transform:none;left:auto;}
      .nav-actions{width:100%;justify-content:space-between;}
      .mobile-toggle{display:inline-flex;}
      .nav-controls{
        position:absolute;
        top:calc(100% + 12px);
        right:clamp(16px,6vw,40px);
        flex-direction:column;
        align-items:stretch;
        gap:var(--space-2);
        padding:var(--space-3);
        border-radius:var(--radius-lg);
        background:var(--surface-elevated);
        box-shadow:var(--shadow-lg);
        min-width:220px;
        display:none;
        z-index:40;
      }
      .nav-controls.open{display:flex;}
      .segmented-control{width:100%;justify-content:space-between;}
      .theme-switch{align-self:flex-start;}
      .chart-stats{grid-template-columns:1fr;}
      .sub-nav__inner{
        grid-template-columns:1fr;
        justify-items:center;
      }
      .sub-nav__inner .tablist,
      .sub-nav__inner .tablist-date{
        grid-column:1;
        justify-self:center;
      }
      .sub-nav__filters{
        grid-column:1;
        justify-self:stretch;
      }
    }
    @media (min-width:1024px){
      .tab-panel{flex-direction:column;}
    }
  </style>
</head>
<body data-theme="dark">
  <header class="top-bar">
    <div class="shell top-bar__inner">
      <div class="brand">Scope</div>
      <div class="brand-title">Gressholmen Kro</div>
      <div class="nav-actions">
        <div class="user-menu" data-menu>
          <button type="button" id="user-menu-trigger" class="chip user-menu__trigger" aria-haspopup="true" aria-expanded="false" aria-controls="user-menu-panel" aria-label="Konto og innstillinger">
            <span class="sr-only">Din konto</span>
            <span class="user-menu__icon" aria-hidden="true">
              <span></span>
              <span></span>
              <span></span>
            </span>
          </button>
          <div class="user-menu__panel" id="user-menu-panel" role="menu" aria-labelledby="user-menu-trigger" hidden>
            <button type="button" class="user-menu__item" role="menuitem">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <circle cx="12" cy="8" r="4"></circle>
                <path d="M4 21a8 8 0 0 1 16 0"></path>
              </svg>
              <span>Bruker</span>
            </button>
            <button type="button" class="user-menu__item" role="menuitem">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <rect x="3" y="5" width="18" height="14" rx="2"></rect>
                <path d="M3 10.5h18"></path>
              </svg>
              <span>Betaling</span>
            </button>
            <button type="button" class="user-menu__item user-menu__item--danger" role="menuitem">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                <path d="M9 6V4a2 2 0 0 1 2-2h5a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2h-5a2 2 0 0 1-2-2v-2"></path>
                <polyline points="13 16 9 12 13 8"></polyline>
                <line x1="9" y1="12" x2="21" y2="12"></line>
              </svg>
              <span>Logg ut</span>
            </button>
          </div>
        </div>
        <button class="mobile-toggle" aria-expanded="false" aria-controls="dash-controls" data-i18n-attr="aria-label:mobile.menu_button">
          <span class="dots" aria-hidden="true"><span></span><span></span><span></span></span>
          <span data-i18n="mobile.menu_button">Meny</span>
        </button>
        <div class="nav-controls" id="dash-controls">
          <div class="segmented-control nav-language" role="group" aria-label="Sprk" data-language-toggle>
            <button type="button" class="segmented-control__option" aria-pressed="true" data-lang="no">NO</button>
            <button type="button" class="segmented-control__option" aria-pressed="false" data-lang="en">EN</button>
          </div>
          <label class="theme-switch mobile-theme-switch" aria-label="Bytt tema">
            <input type="checkbox" id="dash-theme-toggle" aria-label="Tema" />
            <span class="slider">
              <span class="thumb">
                <svg class="icon sun" viewBox="0 0 24 24" aria-hidden="true">
                  <circle cx="12" cy="12" r="5" />
                  <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke-linecap="round" stroke-linejoin="round" />
                </svg>
                <svg class="icon moon" viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M21 12.79A9 9 0 1111.21 3a7 7 0 009.79 9.79z" />
                </svg>
              </span>
            </span>
          </label>
        </div>
      </div>
    </div>
  </header>
  <nav class="sub-nav">
    <div class="shell">
      <div class="sub-nav__inner">
        <div class="tablist" role="tablist" aria-label="Dashboard faner">
          <button class="tab-button active" id="tab-kpi" type="button" role="tab" aria-selected="true" aria-controls="kpi" data-tab-target="kpi" tabindex="0">KPI</button>
          <button class="tab-button" id="tab-oversikt" type="button" role="tab" aria-selected="false" aria-controls="oversikt" data-tab-target="oversikt" tabindex="-1">Oversikt</button>
          <button class="tab-button" id="tab-ai" type="button" role="tab" aria-selected="false" aria-controls="ai-tips" data-tab-target="ai-tips" tabindex="-1">AI-tips</button>
        </div>
        <div class="tablist-date">
          <button type="button" class="tablist-date__today" data-day-today>I dag</button>
          <button type="button" class="tablist-date__trigger" data-day-picker-trigger aria-controls="sales-day-picker" aria-haspopup="dialog">
            <span data-tablist-date></span>
            <svg class="tablist-date__icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M7 4V2M17 4V2M7 11h10M5 7h14v13H5z" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <input type="date" id="sales-day-picker" class="sr-only tablist-date__input" aria-label="Velg dato for dashbordet" tabindex="-1" />
        </div>
        <div class="sub-nav__filters" data-toolbar-for="kpi">
          <div class="reports-toolbar" data-reports-toolbar data-toolbar-mode="simple">
            <div class="reports-range" role="tablist" aria-label="Rapporter periode">
              <button type="button" class="reports-range__btn" data-range="month" aria-expanded="false">Mned</button>
              <button type="button" class="reports-range__btn" data-range="week" aria-expanded="false">Uke</button>
              <button type="button" class="reports-range__btn" data-range="day" aria-expanded="false">Dag</button>
              <span class="reports-range__label" data-range-visible="month,week,day">
                <span class="reports-range__title" aria-hidden="true">Rapport:</span>
                <span class="reports-range__month" data-reports-range-label aria-live="polite"></span>
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </nav>
  <main class="shell">
    <section class="tab-panel active" id="kpi" role="tabpanel" aria-labelledby="tab-kpi" tabindex="0" data-tripletex-config='{"beer":{"label":"l","accounts":{"revenue":"id-289896744","cost":"id-289896742"}},"wine":{"label":"Vin","accounts":{"revenue":"id-289896745","cost":"id-289896743"}}}'>
      <div class="tripletex-grid" data-range-visible="month">
        <article class="card tripletex-card" data-tripletex-product="sales">
          <header>
            <h2 data-tripletex-label>Tripletex  Salg</h2>
            <p class="tripletex-status" data-tripletex-status>Henter </p>
          </header>
          <table class="tripletex-table">
            <thead>
              <tr>
                <th>Mned</th>
                <th>Salgsinntekt</th>
                <th>Varekost</th>
                <th>Dekningsgrad</th>
              </tr>
            </thead>
            <tbody data-tripletex-table>
              <tr><td colspan="4" class="muted">Henter </td></tr>
            </tbody>
          </table>
        </article>
      </div>
      <div class="card range-placeholder" data-range-visible="week" hidden>
        <h2>Ukemeny</h2>
        <p class="muted">Ukebasert visning. Tripletex-tabellene er tilgjengelige nr du velger Mned.</p>
      </div>
      <div class="card range-placeholder" data-range-visible="day" hidden>
        <h2>Dagsmeny</h2>
        <p class="muted">Dagvisning er aktiv. Bytt til Mned for  se mnedsrapporten fra Tripletex.</p>
      </div>
    </section>
    <section class="tab-panel" id="oversikt" role="tabpanel" aria-labelledby="tab-oversikt" tabindex="0" hidden>
      <div class="overview-highlights overview-highlights--stats" aria-label="Omsetning">
        <article class="overview-highlight">
          <span class="overview-highlight__eyebrow">Omsetning</span>
          <p class="overview-highlight__value" data-day-revenue></p>
          <p class="overview-highlight__meta" data-day-status data-tone="muted"></p>
          <span class="overview-highlight__badge" data-day-week-delta></span>
        </article>
        <article class="overview-highlight">
          <span class="overview-highlight__eyebrow">Antall kvitteringer</span>
          <p class="overview-highlight__value" data-day-receipts-value></p>
          <p class="overview-highlight__meta" data-day-receipts-status data-tone="muted"></p>
        </article>
        <article class="overview-highlight">
          <span class="overview-highlight__eyebrow">Snitt per kjp</span>
          <p class="overview-highlight__value" data-day-average></p>
          <p class="overview-highlight__meta" data-day-average-status data-tone="muted"></p>
          <span class="overview-highlight__badge" data-day-average-delta></span>
        </article>
      </div>
      <article class="card ai-hourly-card overview-hourly" data-ai-hourly-card>
        <header class="ai-hourly-card__header">
          <div>
            <span class="ai-hourly-card__eyebrow">Info</span>
            <h2>Salg per tidspunkt p dagen</h2>
            <p class="ai-hourly-card__sub">Oppdatert automatisk sammenlignet med samme ukedag forrige uke.</p>
          </div>
          <div class="ai-hourly-card__meta">
            <span class="ai-hourly-card__tag" data-hourly-tag>Ingen trenddata</span>
            <div class="ai-hourly-card__legend">
              <span><span class="ai-hourly-card__dot ai-hourly-card__dot--current"></span>I dag</span>
              <span><span class="ai-hourly-card__dot ai-hourly-card__dot--previous"></span>Samme dag forrige uke</span>
            </div>
          </div>
        </header>
        <div class="ai-hourly-card__chart">
          <canvas data-hourly-chart width="800" height="280" role="img" aria-label="Salg per time"></canvas>
          <div class="ai-hourly-card__empty" data-hourly-empty hidden>Ingen timetall tilgjengelig enn.</div>
        </div>
        <footer class="ai-hourly-card__footer">
          <div class="ai-hourly-card__stats">
            <div class="ai-hourly-card__stat ai-hourly-card__stat--time">
              <span class="ai-hourly-card__stat-label">Tidspunkt</span>
              <p class="ai-hourly-card__focus-label" data-hourly-focus-label></p>
            </div>
            <div class="ai-hourly-card__stat">
              <span class="ai-hourly-card__stat-label">I dag</span>
              <strong class="ai-hourly-card__stat-value" data-hourly-focus-current></strong>
            </div>
            <div class="ai-hourly-card__stat">
              <span class="ai-hourly-card__stat-label">Samme dag forrige uke</span>
              <strong class="ai-hourly-card__stat-value" data-hourly-focus-previous></strong>
            </div>
            <span class="ai-hourly-card__pill" data-hourly-focus-delta></span>
          </div>
          <p class="ai-hourly-card__note" data-hourly-note></p>
        </footer>
      </article>
      <article class="card chart-card">
        <header>
          <div class="chart-header__main">
            <h2 class="chart-week-heading" data-chart-week-label>Uke </h2>
            <div class="chart-meta">
              <span class="chart-meta__total" data-chart-week-total>Totalt: </span>
              <span class="chart-meta__average" data-chart-week-average>Snitt: </span>
            </div>
          </div>
          <div class="chart-nav">
            <button type="button" class="chart-nav__btn" data-chart-nav="prev" aria-label="Forrige uke"></button>
            <button type="button" class="chart-nav__btn" data-chart-nav="next" aria-label="Neste uke"></button>
          </div>
        </header>
        <div class="bar-chart" data-daily-chart role="img" aria-live="polite" aria-label="Omsetning siste 7 dager"></div>
        <div class="chart-tooltip" data-chart-tooltip hidden></div>
      </article>
    </section>
    <section class="tab-panel" id="ai-tips" role="tabpanel" aria-labelledby="tab-ai" tabindex="0" hidden>
      <div class="ai-section-header">
        <h2>AI-tips</h2>
        <div class="ai-section-header__meta">
          <span data-ai-products-date></span>
          <label for="ai-products-picker" class="sr-only">Velg dato for AI-tips</label>
          <input type="date" id="ai-products-picker" class="daily-summary__input ai-insights__input" />
          <button type="button" class="ai-section-header__today" data-ai-today>i dag</button>
        </div>
      </div>
      <article class="card ai-insights-card">
        <div class="ai-insights" data-ai-insights>
          <div class="ai-insights__column">
            <h3>Mest solgte produkter</h3>
            <ul class="ai-insights__list" data-ai-top-list></ul>
          </div>
          <div class="ai-insights__column">
            <h3>Minst solgte produkter</h3>
            <ul class="ai-insights__list" data-ai-bottom-list></ul>
          </div>
        </div>
        <p class="ai-insights__status" data-ai-products-status></p>
      </article>
      <article class="revenue-card" data-revenue-card>
        <header>
          <h2 class="revenue-card__title">Omsetningsanalyse</h2>
          <div class="revenue-card__meta">
            <span data-revenue-date></span>
            <span data-revenue-comparison></span>
          </div>
        </header>
        <div class="revenue-card__grid">
          <div class="revenue-card__stat">
            <span class="revenue-card__label">Omsetning</span>
            <strong class="revenue-card__value" data-revenue-current></strong>
            <span class="revenue-card__delta" data-revenue-current-note></span>
          </div>
          <div class="revenue-card__stat">
            <span class="revenue-card__label">Mot forrige uke</span>
            <strong class="revenue-card__value" data-revenue-week-delta></strong>
            <span class="revenue-card__delta" data-revenue-week-note></span>
          </div>
          <div class="revenue-card__stat">
            <span class="revenue-card__label">Mot mnedssnitt</span>
            <strong class="revenue-card__value" data-revenue-month-delta></strong>
            <span class="revenue-card__delta" data-revenue-month-note></span>
          </div>
        </div>
        <p class="revenue-card__note" data-revenue-status></p>
      </article>
      <article class="product-change-card" data-product-change-card>
        <header>
          <h2 class="product-change-card__title">Produktendringer</h2>
          <div class="product-change-card__meta">
            <span data-product-change-date></span>
            <span data-product-change-compare></span>
          </div>
        </header>
        <div class="product-change-card__columns">
          <div class="product-change-card__column">
            <h3>Strst vekst</h3>
            <ul class="product-change-card__list" data-product-change-up></ul>
          </div>
          <div class="product-change-card__column">
            <h3>Strst nedgang</h3>
            <ul class="product-change-card__list" data-product-change-down></ul>
          </div>
        </div>
        <p class="product-change-card__status" data-product-change-status></p>
      </article>
    </section>
  </main>
  <script>
    (function() {
      const buttons = Array.from(document.querySelectorAll('.tab-button'));
      const panels = Array.from(document.querySelectorAll('.tab-panel'));
      const contextualToolbars = Array.from(document.querySelectorAll('[data-toolbar-for]'));

      const updateToolbarVisibility = (targetId) => {
        document.body.dataset.activeTab = targetId || '';
        contextualToolbars.forEach((toolbar) => {
          const matches = (toolbar.dataset.toolbarFor || '') === targetId;
          toolbar.hidden = !matches;
          toolbar.setAttribute('aria-hidden', matches ? 'false' : 'true');
        });
      };

      function activateTab(targetId) {
        buttons.forEach((btn) => {
          const isActive = btn.dataset.tabTarget === targetId;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', String(isActive));
          btn.setAttribute('tabindex', isActive ? '0' : '-1');
        });

        panels.forEach((panel) => {
          const isMatch = panel.id === targetId;
          panel.classList.toggle('active', isMatch);
          panel.toggleAttribute('hidden', !isMatch);
        });
        updateToolbarVisibility(targetId);

      }

      // simple tab controller for switching dashboard sections
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => activateTab(btn.dataset.tabTarget));
        btn.addEventListener('keydown', (event) => {
          const index = buttons.indexOf(btn);
          if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
            event.preventDefault();
            const direction = event.key === 'ArrowRight' ? 1 : -1;
            const nextIndex = (index + direction + buttons.length) % buttons.length;
            buttons[nextIndex].focus();
          } else if (event.key === 'Home') {
            event.preventDefault();
            buttons[0].focus();
          } else if (event.key === 'End') {
            event.preventDefault();
            buttons[buttons.length - 1].focus();
          }
        });
      });

      const defaultTab = buttons.find((btn) => btn.classList.contains('active'))?.dataset.tabTarget || buttons[0]?.dataset.tabTarget;
      if (defaultTab) {
        activateTab(defaultTab);
      }

      const moneyFmt = new Intl.NumberFormat('nb-NO', { style: 'currency', currency: 'NOK', maximumFractionDigits: 0 });
      const qtyFmt = new Intl.NumberFormat('nb-NO', { maximumFractionDigits: 0 });
      const percentFmt = new Intl.NumberFormat('nb-NO', { style: 'percent', maximumFractionDigits: 0 });
      const dateFmtShort = new Intl.DateTimeFormat('nb-NO', { day: 'numeric', month: 'short' });
      const dateFmtLong = new Intl.DateTimeFormat('nb-NO', { weekday: 'short', day: 'numeric', month: 'short' });
      const reportMonthFmt = new Intl.DateTimeFormat('nb-NO', { month: 'long', year: 'numeric' });
      let tripletexContext = null;

      const apiBase = window.DASHBOARD_API_BASE || (
        (window.location && window.location.origin) ? window.location.origin : 'http://localhost:8888'
      );

      const toISODate = (date) => {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };

      const PREVIEW_TODAY = '';
      let today = new Date();
      if (PREVIEW_TODAY) {
        const previewDate = new Date(`${PREVIEW_TODAY}T00:00:00`);
        if (!Number.isNaN(previewDate.getTime())) {
          today = previewDate;
        }
      }
      const todayISO = toISODate(today);

      const dayPicker = document.querySelector('#sales-day-picker');
      const dayPickerTrigger = document.querySelector('[data-day-picker-trigger]');
      const dayTodayBtn = document.querySelector('[data-day-today]');
      const dayRevenueEl = document.querySelector('[data-day-revenue]');
      const dayAverageEl = document.querySelector('[data-day-average]');
      const dayStatusEl = document.querySelector('[data-day-status]');
      const dayReceiptsValueEl = document.querySelector('[data-day-receipts-value]');
      const dayReceiptsStatusEl = document.querySelector('[data-day-receipts-status]');
      const dayAverageStatusEl = document.querySelector('[data-day-average-status]');
      const dayWeekDeltaBadgeEl = document.querySelector('[data-day-week-delta]');
      const dayAverageDeltaBadgeEl = document.querySelector('[data-day-average-delta]');
      const tablistDateEl = document.querySelector('[data-tablist-date]');
      const reportsRangeLabelEl = document.querySelector('[data-reports-range-label]');
      const chartBalanceValueEl = document.querySelector('[data-balance-value]');
      const chartBalanceStatusEl = document.querySelector('[data-balance-status]');
      const highlightBankValueEl = document.querySelector('[data-highlight-bank]');
      const highlightBankMetaEl = document.querySelector('[data-highlight-bank-meta]');
      const highlightDueValueEl = document.querySelector('[data-highlight-due]');
      const highlightDueMetaEl = document.querySelector('[data-highlight-due-meta]');
      const highlightNetValueEl = document.querySelector('[data-highlight-net]');
      const highlightNetMetaEl = document.querySelector('[data-highlight-net-meta]');
      const barChart = document.querySelector('[data-daily-chart]');
      const chartPrevBtn = document.querySelector('[data-chart-nav="prev"]');
      const chartNextBtn = document.querySelector('[data-chart-nav="next"]');
      const chartWeekLabel = document.querySelector('[data-chart-week-label]');
      const chartWeekTotal = document.querySelector('[data-chart-week-total]');
      const chartWeekAverage = document.querySelector('[data-chart-week-average]');
      const chartTooltip = document.querySelector('[data-chart-tooltip]');
      const chartCard = barChart ? barChart.closest('.chart-card') : null;
      const weekdayFmt = new Intl.DateTimeFormat('nb-NO', { weekday: 'short' });
      const chartDateFmt = new Intl.DateTimeFormat('nb-NO', { day: '2-digit', month: '2-digit' });
      const aiTopListEl = document.querySelector('[data-ai-top-list]');
      const aiBottomListEl = document.querySelector('[data-ai-bottom-list]');
      const aiProductsStatusEl = document.querySelector('[data-ai-products-status]');
      const aiProductsDateEl = document.querySelector('[data-ai-products-date]');
      const aiProductsPicker = document.querySelector('#ai-products-picker');
      const aiTodayBtn = document.querySelector('[data-ai-today]');
      const rangeVisibilityTargets = Array.from(document.querySelectorAll('[data-range-visible]'));
      const applyRangeVisibility = (range) => {
        const safeRange = range || 'month';
        document.body.dataset.reportsRange = safeRange;
        rangeVisibilityTargets.forEach((target) => {
          const allowed = (target.dataset.rangeVisible || '')
            .split(',')
            .map((entry) => entry.trim())
            .filter(Boolean);
          const shouldShow = !allowed.length || allowed.includes(safeRange);
          if (shouldShow) {
            target.hidden = false;
            target.removeAttribute('data-range-hidden');
          } else {
            target.hidden = true;
            target.setAttribute('data-range-hidden', '1');
          }
        });
      };
      applyRangeVisibility('month');
      let handleActiveDateChange = null;
      const hourlyCardEl = document.querySelector('[data-ai-hourly-card]');
      const hourlyCanvas = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-chart]') : null;
      const hourlyEmptyEl = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-empty]') : null;
      const hourlyTagEl = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-tag]') : null;
      const hourlyFocusLabelEl = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-focus-label]') : null;
      const hourlyFocusCurrentEl = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-focus-current]') : null;
      const hourlyFocusPreviousEl = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-focus-previous]') : null;
      const hourlyFocusDeltaEl = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-focus-delta]') : null;
      const hourlyNoteEl = hourlyCardEl ? hourlyCardEl.querySelector('[data-hourly-note]') : null;
      const rawReportsToolbar = document.querySelector('[data-reports-toolbar]');
      const isSimpleReportsToolbar = rawReportsToolbar?.dataset.toolbarMode === 'simple';
      const reportsToolbar = rawReportsToolbar;

    if (isSimpleReportsToolbar && rawReportsToolbar) {
      const monthButton = rawReportsToolbar.querySelector('[data-range="month"]');
      const monthPanel = rawReportsToolbar.querySelector('[data-range-panel="month"]');
      const weekButton = rawReportsToolbar.querySelector('[data-range="week"]');
      const weekPanel = rawReportsToolbar.querySelector('[data-range-panel="week"]');
      const dayButton = rawReportsToolbar.querySelector('[data-range="day"]');
      const simpleRangeButtons = Array.from(rawReportsToolbar.querySelectorAll('[data-range]'));

      let closeMonthMenu = () => {};
      let openMonthMenu = () => {};
      let closeWeekMenu = () => {};
      let openWeekMenu = () => {};
      let clearMonthSelection = () => {};
      let clearWeekSelection = () => {};

      const setSimpleRangeSelection = (range) => {
        applyRangeVisibility(range);
        simpleRangeButtons.forEach((btn) => {
          const isActive = btn.dataset.range === range;
          btn.classList.toggle('active', isActive);
          if (isActive) {
            btn.setAttribute('data-selected', 'true');
          } else {
            btn.removeAttribute('data-selected');
          }
          btn.setAttribute('aria-expanded', 'false');
        });
      };

      if (monthButton && monthPanel) {
        const monthButtons = Array.from(monthPanel.querySelectorAll('.reports-month'));
        const defaultLabel = monthButton.textContent.trim();
        let selectedMonth = null;
        let selectedMonthLabel = '';

        const getSelectedMonthLabel = () => {
          if (!selectedMonth) return '';
          if (selectedMonthLabel) return selectedMonthLabel;
          const match = monthButtons.find((btn) => btn.dataset.month === selectedMonth);
          return match ? match.textContent.trim() : selectedMonth;
        };

        const updateMonthTriggerState = () => {
          const hasSelection = Boolean(selectedMonth);
          monthButton.textContent = defaultLabel;
          if (hasSelection) monthButton.setAttribute('data-selected', 'true');
          else monthButton.removeAttribute('data-selected');
        };

        const syncMonthButtonStates = () => {
          monthButtons.forEach((btn) => {
            const isSelected = selectedMonth && btn.dataset.month === selectedMonth;
            btn.classList.toggle('selected', isSelected);
            btn.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
          });
          updateMonthTriggerState();
        };

        clearMonthSelection = () => {
          selectedMonth = null;
          selectedMonthLabel = '';
          syncMonthButtonStates();
        };

        closeMonthMenu = () => {
          monthPanel.hidden = true;
          monthPanel.removeAttribute('data-open');
          monthButton.classList.remove('active');
          monthButton.setAttribute('aria-expanded', 'false');
        };

        openMonthMenu = () => {
          closeWeekMenu();
          monthPanel.hidden = false;
          monthPanel.dataset.open = 'true';
          monthButton.classList.add('active');
          monthButton.setAttribute('aria-expanded', 'true');
          syncMonthButtonStates();
        };

        syncMonthButtonStates();
        closeMonthMenu();

        monthButton.addEventListener('click', (event) => {
          event.stopPropagation();
          const isOpen = !monthPanel.hidden;
          if (isOpen) {
            closeMonthMenu();
          } else {
            openMonthMenu();
          }
        });

        monthPanel.addEventListener('click', (event) => {
          const trigger = event.target.closest('.reports-month');
          if (!trigger) return;
          selectedMonth = trigger.dataset.month;
          selectedMonthLabel = trigger.textContent.trim();
          syncMonthButtonStates();
          clearWeekSelection();
          dayButton?.removeAttribute('data-selected');
          closeMonthMenu();
        });
      }

      if (weekButton && weekPanel) {
        const weekGrid = weekPanel.querySelector('[data-simple-week-grid], .reports-week-grid');
        const defaultWeekLabel = weekButton.textContent.trim();
        let selectedWeek = null;
        let selectedWeekLabel = '';
        let weekButtons = [];

          const updateWeekTriggerState = () => {
            if (selectedWeek) {
              const suffix = selectedWeekLabel || `Uke ${selectedWeek}`;
              weekButton.textContent = `${defaultWeekLabel}  ${suffix}`;
              weekButton.setAttribute('data-selected', 'true');
            } else {
              weekButton.textContent = defaultWeekLabel;
              weekButton.removeAttribute('data-selected');
            }
          };

        const ensureWeekButtons = () => {
          if (!weekGrid) return;
          if (weekGrid.dataset.simpleGenerated === '1') {
            weekButtons = Array.from(weekGrid.querySelectorAll('.reports-week'));
            return;
          }
          weekGrid.innerHTML = '';
          for (let week = 1; week <= 53; week += 1) {
            const weekValue = String(week).padStart(2, '0');
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'reports-week';
            button.dataset.week = weekValue;
            button.textContent = `Uke ${weekValue}`;
            button.setAttribute('aria-pressed', 'false');
            weekGrid.appendChild(button);
          }
          weekGrid.dataset.simpleGenerated = '1';
          weekButtons = Array.from(weekGrid.querySelectorAll('.reports-week'));
        };

        const syncWeekButtonStates = () => {
          ensureWeekButtons();
          weekButtons.forEach((btn) => {
            const isSelected = selectedWeek && btn.dataset.week === selectedWeek;
            btn.classList.toggle('selected', isSelected);
            btn.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
            if (isSelected) btn.setAttribute('data-active', 'true');
            else btn.removeAttribute('data-active');
          });
          updateWeekTriggerState();
        };

        clearWeekSelection = () => {
          selectedWeek = null;
          selectedWeekLabel = '';
          if (weekGrid && weekGrid.dataset.simpleGenerated === '1') {
            weekButtons = Array.from(weekGrid.querySelectorAll('.reports-week'));
            weekButtons.forEach((btn) => {
              btn.classList.remove('selected');
              btn.removeAttribute('data-active');
              btn.setAttribute('aria-pressed', 'false');
            });
          }
          updateWeekTriggerState();
        };

        closeWeekMenu = () => {
          weekPanel.hidden = true;
          weekPanel.removeAttribute('data-open');
          weekButton.classList.remove('active');
          weekButton.setAttribute('aria-expanded', 'false');
        };

        openWeekMenu = () => {
          closeMonthMenu();
          ensureWeekButtons();
          weekPanel.hidden = false;
          weekPanel.dataset.open = 'true';
          weekButton.classList.add('active');
          weekButton.setAttribute('aria-expanded', 'true');
          syncWeekButtonStates();
        };

        clearWeekSelection();
        closeWeekMenu();

        weekButton.addEventListener('click', (event) => {
          event.stopPropagation();
          const isOpen = !weekPanel.hidden;
          if (isOpen) {
            closeWeekMenu();
          } else {
            openWeekMenu();
          }
        });

        weekPanel.addEventListener('click', (event) => {
          const trigger = event.target.closest('.reports-week');
          if (!trigger) return;
          selectedWeek = trigger.dataset.week;
          selectedWeekLabel = trigger.textContent.trim();
          syncWeekButtonStates();
          clearMonthSelection();
          dayButton?.removeAttribute('data-selected');
          closeWeekMenu();
        });
      }

      const closeAllSimplePanels = () => {
        closeMonthMenu();
        closeWeekMenu();
      };

      if (monthButton) {
        monthButton.addEventListener('click', () => {
          closeAllSimplePanels();
          clearWeekSelection();
          setSimpleRangeSelection('month');
          updateReportsRangeLabel(activeDateISO, 'month');
        });
      }

      if (weekButton) {
        weekButton.addEventListener('click', () => {
          closeAllSimplePanels();
          clearMonthSelection();
          setSimpleRangeSelection('week');
          updateReportsRangeLabel(activeDateISO, 'week');
        });
      }

      if (dayButton) {
        dayButton.addEventListener('click', () => {
          closeAllSimplePanels();
          clearMonthSelection();
          clearWeekSelection();
          setSimpleRangeSelection('day');
          updateReportsRangeLabel(activeDateISO, 'day');
        });
      }

      document.addEventListener('click', (event) => {
        if (!rawReportsToolbar.contains(event.target)) {
          closeAllSimplePanels();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key !== 'Escape') return;
        if (monthPanel && !monthPanel.hidden) {
          closeMonthMenu();
          monthButton?.focus();
          return;
        }
        if (weekPanel && !weekPanel.hidden) {
          closeWeekMenu();
          weekButton?.focus();
        }
      });
      setSimpleRangeSelection('month');
    }
      const revenueCardEl = document.querySelector('[data-revenue-card]');
      const revenueDateEl = document.querySelector('[data-revenue-date]');
      const revenueComparisonEl = document.querySelector('[data-revenue-comparison]');
      const revenueCurrentEl = document.querySelector('[data-revenue-current]');
      const revenueCurrentNoteEl = document.querySelector('[data-revenue-current-note]');
      const revenueWeekDeltaEl = document.querySelector('[data-revenue-week-delta]');
      const revenueWeekNoteEl = document.querySelector('[data-revenue-week-note]');
      const revenueMonthDeltaEl = document.querySelector('[data-revenue-month-delta]');
      const revenueMonthNoteEl = document.querySelector('[data-revenue-month-note]');
      const revenueStatusEl = document.querySelector('[data-revenue-status]');
      let chartDataAll = [];
      let chartDataMap = new Map();
      let chartCursorDate = null;
      let chartLatestDate = todayISO;
      let chartOldestDate = todayISO;
      let chartIsDemo = false;
      let chartNavBusy = false;
      let lastDayTotals = null;
      let revenueAnalysisContext = { date: null, fallbackDaily: [], entry: null };
      const hourlySeriesCache = new Map();
      let latestBankBalance = 0;
      let dueAmountNext3Days = 0;
      const PREVIEW_DAY_TOTALS = {
        '2025-08-10': { revenue: 150763, receipts: 429 },
        '2025-08-03': { revenue: 57476, receipts: 388 },
      };
      const PREVIEW_TRIPLETEX = {
        month: {
          from: '2025-01-01',
          to: '2025-01-31',
          accounts: [
            {
              key: 'beerRevenue',
              label: 'l salg',
              total: 15808,
              totalAbsolute: 15808,
              periods: {
                '2025-01': {
                  total: 15808,
                  totalAbsolute: 15808,
                  firstDate: '2025-01-22',
                  lastDate: '2025-01-22',
                  meta: { start: '2025-01-01', end: '2025-01-31', year: 2025, month: 1 },
                },
              },
            },
            {
              key: 'beerCost',
              label: 'l varekost',
              total: 0,
              totalAbsolute: 0,
              periods: {
                '2025-01': {
                  total: 0,
                  totalAbsolute: 0,
                  firstDate: '2025-01-01',
                  lastDate: '2025-01-31',
                  meta: { start: '2025-01-01', end: '2025-01-31', year: 2025, month: 1 },
                },
              },
            },
            {
              key: 'wineRevenue',
              label: 'Vin salg',
              total: 0,
              totalAbsolute: 0,
              periods: {
                '2025-01': {
                  total: 0,
                  totalAbsolute: 0,
                  firstDate: '2025-01-01',
                  lastDate: '2025-01-31',
                  meta: { start: '2025-01-01', end: '2025-01-31', year: 2025, month: 1 },
                },
              },
            },
            {
              key: 'wineCost',
              label: 'Vin varekost',
              total: 0,
              totalAbsolute: 0,
              periods: {
                '2025-01': {
                  total: 0,
                  totalAbsolute: 0,
                  firstDate: '2025-01-01',
                  lastDate: '2025-01-31',
                  meta: { start: '2025-01-01', end: '2025-01-31', year: 2025, month: 1 },
                },
              },
            },
          ],
        },
      };
      const defaultHourlySeriesSeeds = {
        '2025-08-10': [0,0,0,0,0,0,35,60,120,200,320,420,520,480,430,410,430,520,580,420,260,140,60,15],
        '2025-08-03': [0,0,0,0,0,0,20,40,80,120,150,180,210,190,175,160,170,210,240,200,150,90,45,12],
        '2024-08-07': [50,55,60,70,95,130,165,185,205,215,210,198,182,168,155,150,165,205,228,220,190,140,95,65],
        '2024-07-31': [42,46,58,68,88,118,150,170,188,198,188,176,162,150,142,138,150,185,205,198,170,128,90,62],
        '2024-07-19': [45,48,55,60,78,110,140,165,182,190,176,165,150,138,133,128,148,190,215,208,175,125,82,60],
        '2024-07-12': [40,44,58,65,90,120,155,180,195,205,190,178,162,150,145,140,155,182,200,194,168,130,95,70],
      };
      const hourlySeedDates = new Set(Object.keys(defaultHourlySeriesSeeds));
      const updateDayWeekDeltaBadge = () => {
        if (!dayWeekDeltaBadgeEl) return;
        const currentEntry = revenueAnalysisContext.entry || lastDayTotals;
        if (!currentEntry?.date) {
          dayWeekDeltaBadgeEl.textContent = '';
          dayWeekDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          return;
        }
        const currentRevenue = Number(currentEntry.revenue || 0);
        const prevIso = sanitizeIso(shiftIsoDate(currentEntry.date, -7));
        if (!prevIso || !(currentRevenue > 0)) {
          dayWeekDeltaBadgeEl.textContent = '';
          dayWeekDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          return;
        }
        let prevRevenue = PREVIEW_DAY_TOTALS[prevIso]?.revenue;
        if (!(prevRevenue > 0)) {
          const fallbackPrev = (revenueAnalysisContext.fallbackDaily || []).find((entry) => entry?.date === prevIso);
          if (fallbackPrev) prevRevenue = Number(fallbackPrev.revenue || 0);
        }
        if (!(prevRevenue > 0)) {
          const fromChart = getDailyEntry(prevIso, revenueAnalysisContext.fallbackDaily || []);
          if (fromChart) prevRevenue = Number(fromChart.revenue || 0);
        }
        if (!(prevRevenue > 0)) {
          dayWeekDeltaBadgeEl.textContent = '';
          dayWeekDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          return;
        }
        const delta = (currentRevenue - prevRevenue) / prevRevenue;
        const deltaLabel = percentFmt.format(delta);
        dayWeekDeltaBadgeEl.textContent = `${delta >= 0 ? '+' : ''}${deltaLabel} vs forrige uke`;
        dayWeekDeltaBadgeEl.classList.toggle('trend-positive', delta >= 0);
        dayWeekDeltaBadgeEl.classList.toggle('trend-negative', delta < 0);
      };

      const updateDayAverageDeltaBadge = (entryOverride = null, fallbackOverride = null) => {
        if (!dayAverageDeltaBadgeEl) return;
        const currentEntry = entryOverride || revenueAnalysisContext.entry || lastDayTotals;
        if (!currentEntry?.date) {
          dayAverageDeltaBadgeEl.textContent = '';
          dayAverageDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          return;
        }
        const receipts = Number(currentEntry.receipts || 0);
        const revenueValue = Number(currentEntry.revenue || 0);
        if (!(receipts > 0 && revenueValue > 0)) {
          dayAverageDeltaBadgeEl.textContent = '';
          dayAverageDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          return;
        }
        const avg = revenueValue / receipts;
        const prevIso = sanitizeIso(shiftIsoDate(currentEntry.date, -7));
        if (!prevIso) {
          dayAverageDeltaBadgeEl.textContent = '';
          dayAverageDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          return;
        }
        let prevRevenue = PREVIEW_DAY_TOTALS[prevIso]?.revenue;
        let prevReceipts = PREVIEW_DAY_TOTALS[prevIso]?.receipts;
        const fallbackPool = fallbackOverride || revenueAnalysisContext.fallbackDaily || [];
        if (!(prevRevenue > 0 && prevReceipts > 0)) {
          const fallbackPrev = fallbackPool.find((entry) => entry?.date === prevIso);
          if (fallbackPrev) {
            prevRevenue = Number(fallbackPrev.revenue || 0);
            prevReceipts = Number(fallbackPrev.receipts || 0);
          }
        }
        if (!(prevRevenue > 0 && prevReceipts > 0)) {
          const fromChart = getDailyEntry(prevIso, fallbackPool);
          if (fromChart) {
            prevRevenue = Number(fromChart.revenue || 0);
            prevReceipts = Number(fromChart.receipts || 0);
          }
        }
        if (!(prevRevenue > 0 && prevReceipts > 0)) {
          dayAverageDeltaBadgeEl.textContent = '';
          dayAverageDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          return;
        }
      const prevAvg = prevRevenue / prevReceipts;
      const delta = (avg - prevAvg) / prevAvg;
      const deltaLabel = percentFmt.format(delta);
      dayAverageDeltaBadgeEl.textContent = `${delta >= 0 ? '+' : ''}${deltaLabel} vs forrige uke`;
      dayAverageDeltaBadgeEl.classList.toggle('trend-positive', delta >= 0);
      dayAverageDeltaBadgeEl.classList.toggle('trend-negative', delta < 0);
    };

      const refreshHourlyChartSeries = (iso, { comparison = false } = {}) => {
        if (!hourlyChartState) return;
        const key = sanitizeIso(iso);
        if (!key) return;
        const cached = hourlySeriesCache.get(key);
        if (!Array.isArray(cached) || !cached.length) return;
        let chartUpdated = false;
        if (!comparison && hourlyChartState.date === key) {
          hourlyChartState.current = cached;
          chartUpdated = true;
        }
        if (comparison && hourlyChartState.compareIso === key) {
          hourlyChartState.comparison = cached;
          chartUpdated = true;
        }
        if (chartUpdated) {
          drawHourlyChart(hourlyChartState);
          updateHourlyFocus(hourlyChartState);
        }
      };

      const scaleHourlySeriesToTotal = (date, targetTotal, { comparison = false } = {}) => {
        const key = sanitizeIso(date);
        const target = Number(targetTotal || 0);
        if (!key || !(target > 0)) {
          refreshHourlyChartSeries(key, { comparison });
          return;
        }
        const series = hourlySeriesCache.get(key);
        if (!Array.isArray(series) || !series.length) {
          refreshHourlyChartSeries(key, { comparison });
          return;
        }
        const originalSum = series.reduce((sum, value) => sum + Number(value || 0), 0);
        let scaledSeries = series;
        if (originalSum > 0 && Math.abs(originalSum - target) >= 1) {
          scaledSeries = series.map((value) => (Number(value || 0) * target) / originalSum);
          const correction = target - scaledSeries.reduce((sum, value) => sum + value, 0);
          if (scaledSeries.length) scaledSeries[scaledSeries.length - 1] += correction;
          hourlySeriesCache.set(key, scaledSeries);
        }
        refreshHourlyChartSeries(key, { comparison });
      };

      const setHourlyFocusHour = (hour = null) => {
        if (!hourlyChartState) return;
        const fallback = hourlyChartState.defaultFocusHour;
        let target = hour;
        if (target == null || Number.isNaN(target)) target = fallback;
        const startHour = hourlyChartState.startHour ?? 0;
        const endHour = hourlyChartState.endHour ?? (HOURLY_HOURS.length - 1);
        target = Math.max(startHour, Math.min(endHour, Math.round(target)));
        if (hourlyChartState.focusHour === target) return;
        hourlyChartState.focusHour = target;
        updateHourlyFocus(hourlyChartState);
      };
      const updateNetHighlight = () => {
        const net = latestBankBalance - dueAmountNext3Days;
        if (highlightNetValueEl) {
          highlightNetValueEl.textContent = moneyFmt.format(net);
          highlightNetValueEl.classList.toggle('positive', net > 0);
          highlightNetValueEl.classList.toggle('negative', net < 0);
        }
        if (highlightNetMetaEl) {
          highlightNetMetaEl.textContent = dueAmountNext3Days > 0
            ? `Bankkonto ${moneyFmt.format(latestBankBalance)}  forfall ${moneyFmt.format(dueAmountNext3Days)}`
            : '';
        }
      };
      const setDueHighlight = (value = 0, metaText = '') => {
        dueAmountNext3Days = Math.max(0, Number(value) || 0);
        if (highlightDueValueEl) {
          highlightDueValueEl.textContent = dueAmountNext3Days ? moneyFmt.format(dueAmountNext3Days) : '0 kr';
          highlightDueValueEl.classList.remove('positive');
          highlightDueValueEl.classList.toggle('negative', dueAmountNext3Days > latestBankBalance);
        }
        if (highlightDueMetaEl) {
          highlightDueMetaEl.textContent = dueAmountNext3Days > 0 ? (metaText || 'Planlagte betalinger') : '';
        }
        updateNetHighlight();
      };
      setDueHighlight(0, '');
      if (typeof window !== 'undefined' && Number.isFinite(window.DASHBOARD_DUE_AMOUNT)) {
        setDueHighlight(window.DASHBOARD_DUE_AMOUNT, 'Planlagte betalinger');
      }
      let hourlyChartState = null;
      const productChangeCardEl = document.querySelector('[data-product-change-card]');
      const productChangeDateEl = document.querySelector('[data-product-change-date]');
      const productChangeCompareEl = document.querySelector('[data-product-change-compare]');
      const productChangeUpEl = document.querySelector('[data-product-change-up]');
      const productChangeDownEl = document.querySelector('[data-product-change-down]');
      const productChangeStatusEl = document.querySelector('[data-product-change-status]');
      let productChangeContext = { date: null, items: [], options: {}, isDemo: false };

      const renderDayStatus = (message, tone = 'muted') => {
        if (!dayStatusEl) return;
        dayStatusEl.textContent = message || '';
        dayStatusEl.dataset.tone = tone;
      };

      const setAiProductsStatus = (message = '', tone = '') => {
        if (!aiProductsStatusEl) return;
        aiProductsStatusEl.textContent = message || '';
        if (tone) {
          aiProductsStatusEl.dataset.tone = tone;
        } else {
          aiProductsStatusEl.removeAttribute('data-tone');
        }
      };

      const buildProductListItem = ({ name, revenue, quantity }) => {
        const itemEl = document.createElement('li');
        itemEl.className = 'ai-insights__item';
        const nameEl = document.createElement('span');
        nameEl.className = 'ai-insights__product';
        nameEl.textContent = name;
        const metricEl = document.createElement('span');
        metricEl.className = 'ai-insights__metric';
        const parts = [];
        const safeRevenue = Number.isFinite(revenue) ? revenue : 0;
        parts.push(moneyFmt.format(safeRevenue));
        if (Number.isFinite(quantity) && quantity > 0) {
          parts.push(`${qtyFmt.format(quantity)} stk`);
        }
        metricEl.textContent = parts.join('  ');
        itemEl.append(nameEl, metricEl);
        return itemEl;
      };

      const sanitizeIso = (iso) => {
        if (!iso) return null;
        const value = String(iso).trim();
        return /^\d{4}-\d{2}-\d{2}$/.test(value) ? value : null;
      };
      const setTodayButtonState = (iso) => {
        if (!dayTodayBtn) return;
        const isToday = sanitizeIso(iso) === todayISO;
        dayTodayBtn.disabled = isToday;
        dayTodayBtn.setAttribute('aria-pressed', isToday ? 'true' : 'false');
        dayTodayBtn.classList.toggle('tablist-date__today--active', isToday);
      };

        const mergePreviewDayTotals = (entry, forcedIso = null, { enabled = true } = {}) => {
          if (!entry && !forcedIso) return null;
          const base = entry ? { ...entry } : { date: forcedIso };
          const iso = sanitizeIso(base.date || forcedIso);
          if (!iso || !enabled) return base;
          const preview = PREVIEW_DAY_TOTALS[iso];
          return preview ? { ...base, ...preview } : base;
        };

      const buildTripletexPreview = (rangeType, { from, to, year }) => {
        if (rangeType !== 'month') return null;
        const payload = PREVIEW_TRIPLETEX.month;
        if (!payload) return null;
        return normalizeTripletexResponse(
          {
            dateFrom: payload.from || from,
            dateTo: payload.to || to,
            group: 'month',
            accounts: payload.accounts || [],
          },
          { rangeType: 'month', from, to, year }
        );
      };

      const parseIsoDate = (iso) => {
        const clean = sanitizeIso(iso);
        if (!clean) return null;
        const parsed = new Date(`${clean}T00:00:00`);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
      };

      const formatFriendlyDate = (iso) => {
        const parsed = parseIsoDate(iso);
        if (!parsed) return '';
        const formatted = dateFmtLong.format(parsed);
        return formatted.charAt(0).toUpperCase() + formatted.slice(1);
      };
      const getISOWeekInfo = (iso) => {
        const parsed = parseIsoDate(iso);
        if (!parsed) return null;
        const target = new Date(parsed);
        target.setHours(0, 0, 0, 0);
        const day = target.getDay() === 0 ? 7 : target.getDay();
        target.setDate(target.getDate() + 4 - day);
        const yearStart = new Date(target.getFullYear(), 0, 1);
        const week = Math.ceil((((target - yearStart) / 86400000) + 1) / 7);
        return { week, year: target.getFullYear() };
      };

      const formatReportMonth = (iso) => {
        const parsed = parseIsoDate(iso);
        if (!parsed) return '';
        const prevMonth = new Date(parsed.getFullYear(), parsed.getMonth() - 1, 1);
        const formatted = reportMonthFmt.format(prevMonth);
        return formatted.charAt(0).toUpperCase() + formatted.slice(1);
      };

      const formatReportRangeLabel = (iso, range = 'month') => {
        const parsed = parseIsoDate(iso);
        if (!parsed) return '';
        const safeRange = ['month', 'week', 'day'].includes(range) ? range : 'month';
        if (safeRange === 'week') {
          const previousWeek = new Date(parsed);
          previousWeek.setDate(previousWeek.getDate() - 7);
          const info = getISOWeekInfo(toISODate(previousWeek));
          return info ? `Uke ${info.week}` : '';
        }
        if (safeRange === 'day') {
          const previousDay = new Date(parsed);
          previousDay.setDate(previousDay.getDate() - 1);
          return dateFmtShort.format(previousDay).replace(/\.$/, '');
        }
        return formatReportMonth(iso);
      };

      const updateReportsRangeLabel = (iso, range = null) => {
        if (!reportsRangeLabelEl) return;
        const resolvedRange = range || document.body.dataset.reportsRange || 'month';
        if (resolvedRange === 'month' && tripletexContext?.monthKey) {
          const [y, m] = tripletexContext.monthKey.split('-').map((v) => Number(v));
          if (Number.isFinite(y) && Number.isFinite(m)) {
            const parsed = new Date(y, m - 1, 1);
            const label = reportMonthFmt.format(parsed);
            reportsRangeLabelEl.textContent = label.charAt(0).toUpperCase() + label.slice(1);
            return;
          }
        }
        reportsRangeLabelEl.textContent = formatReportRangeLabel(iso, resolvedRange);
      };

      const updateSelectedDateUI = (nextIso, source = null) => {
        const iso = sanitizeIso(nextIso) || todayISO;
        if (tablistDateEl) {
          tablistDateEl.textContent = formatFriendlyDate(iso);
        }
        setTodayButtonState(iso);
        if (dayPicker && source !== 'day') {
          dayPicker.value = iso;
        }
        if (aiProductsPicker && source !== 'ai') {
          aiProductsPicker.value = iso;
        }
        updateReportsRangeLabel(iso);
        return iso;
      };
      let activeDateISO = updateSelectedDateUI(dayPicker?.value || aiProductsPicker?.value || todayISO);

      const shiftIsoDate = (iso, delta) => {
        const parsed = parseIsoDate(iso);
        if (!parsed) return null;
        const shifted = new Date(parsed);
        shifted.setDate(parsed.getDate() + delta);
        return toISODate(shifted);
      };

      const formatSignedCurrency = (value) => {
        if (!Number.isFinite(value)) return '';
        if (value === 0) return moneyFmt.format(0);
        const abs = Math.abs(value);
        const formatted = moneyFmt.format(abs);
        return value > 0 ? `+${formatted}` : `-${formatted}`;
      };

      const formatSignedPercent = (value) => {
        if (!Number.isFinite(value)) return null;
        if (value === 0) return '0 %';
        const formatted = percentFmt.format(Math.abs(value));
        return value > 0 ? `+${formatted}` : `-${formatted}`;
      };

      const setDeltaTone = (el, value) => {
        if (!el) return;
        if (!Number.isFinite(value)) {
          el.dataset.tone = 'flat';
          return;
        }
        if (value === 0) {
          el.dataset.tone = 'flat';
        } else {
          el.dataset.tone = value > 0 ? 'up' : 'down';
        }
      };

      const formatSignedQuantity = (value) => {
        if (!Number.isFinite(value) || value === 0) return value === 0 ? '0' : null;
        const formatted = qtyFmt.format(Math.abs(value));
        return value > 0 ? `+${formatted}` : `-${formatted}`;
      };

      const normalizeProductItems = (items = []) => {
        const map = new Map();
        items.forEach((entry) => {
          if (!entry) return;
          const name = String(entry?.name || '').trim();
          if (!name) return;
          const key = name.toLowerCase();
          const revenue = Number(entry?.revenue || 0);
          const quantity = Number(entry?.quantity ?? entry?.qty ?? 0);
          const existing = map.get(key) || { name, revenue: 0, quantity: 0 };
          existing.revenue += Number.isFinite(revenue) ? revenue : 0;
          existing.quantity += Number.isFinite(quantity) ? quantity : 0;
          map.set(key, existing);
        });
        return map;
      };

      const computeProductChanges = (currentItems = [], previousItems = []) => {
        const currMap = normalizeProductItems(currentItems);
        const prevMap = normalizeProductItems(previousItems);
        const changes = [];

        currMap.forEach((current, key) => {
          const previous = prevMap.get(key) || { name: current.name, revenue: 0, quantity: 0 };
          const revenueChange = Number(current.revenue || 0) - Number(previous.revenue || 0);
          const quantityChange = Number(current.quantity || 0) - Number(previous.quantity || 0);
          const pctChange = Number(previous.revenue || 0) > 0 ? revenueChange / Number(previous.revenue || 0) : null;
          changes.push({
            key,
            name: current.name,
            revenueCurrent: Number(current.revenue || 0),
            revenuePrevious: Number(previous.revenue || 0),
            revenueChange,
            quantityCurrent: Number(current.quantity || 0),
            quantityPrevious: Number(previous.quantity || 0),
            quantityChange,
            percentChange: pctChange,
          });
          prevMap.delete(key);
        });

        prevMap.forEach((previous, key) => {
          const revenueChange = -Number(previous.revenue || 0);
          const quantityChange = -Number(previous.quantity || 0);
          changes.push({
            key,
            name: previous.name,
            revenueCurrent: 0,
            revenuePrevious: Number(previous.revenue || 0),
            revenueChange,
            quantityCurrent: 0,
            quantityPrevious: Number(previous.quantity || 0),
            quantityChange,
            percentChange: previous.revenue > 0 ? -1 : null,
          });
        });

        const increases = changes
          .filter((entry) => entry.revenueChange > 0)
          .sort((a, b) => b.revenueChange - a.revenueChange);

        const decreases = changes
          .filter((entry) => entry.revenueChange < 0)
          .sort((a, b) => a.revenueChange - b.revenueChange);

        return { increases, decreases };
      };

      const buildProductChangeItem = (entry, { compareLabel } = {}) => {
        const li = document.createElement('li');
        li.className = 'product-change-card__item';
        const tone = entry.revenueChange > 0 ? 'up' : entry.revenueChange < 0 ? 'down' : 'flat';
        li.dataset.tone = tone;

        const nameEl = document.createElement('span');
        nameEl.className = 'product-change-card__name';
        nameEl.textContent = entry.name || 'Ukjent produkt';

        const metricsEl = document.createElement('span');
        metricsEl.className = 'product-change-card__metrics';
        const parts = [];
        const currencyLabel = formatSignedCurrency(entry.revenueChange);
        if (currencyLabel) parts.push(currencyLabel);
        const percentLabel = formatSignedPercent(entry.percentChange);
        if (percentLabel) {
          parts.push(percentLabel);
        } else if (!Number.isFinite(entry.percentChange)) {
          if (entry.revenuePrevious === 0 && entry.revenueCurrent > 0) parts.push('ny');
          if (entry.revenueCurrent === 0 && entry.revenuePrevious > 0) parts.push('ut');
        }
        const quantityLabel = formatSignedQuantity(entry.quantityChange);
        if (quantityLabel && entry.quantityChange !== 0) {
          parts.push(`${quantityLabel} stk`);
        }
        if (parts.length === 0) parts.push('');
        metricsEl.textContent = parts.join('  ');

        li.append(nameEl, metricsEl);
        return li;
      };

      const renderProductInsights = (items, { date, state = 'ready', message = '', isDemo = false } = {}) => {
        if (aiProductsDateEl) {
          const parsed = date ? new Date(`${date}T00:00:00`) : null;
          const formatted = parsed && !Number.isNaN(parsed.getTime()) ? dateFmtLong.format(parsed) : (date || '');
          aiProductsDateEl.textContent = formatted ? `Tall for ${formatted}` : '';
        }

        if (aiTopListEl) aiTopListEl.innerHTML = '';
        if (aiBottomListEl) aiBottomListEl.innerHTML = '';

        if (state === 'loading') {
          setAiProductsStatus('Henter produktinnsikt ');
          return;
        }

        if (state === 'error') {
          setAiProductsStatus(message || 'Kunne ikke hente produktinnsikt.', 'error');
          return;
        }

        const processed = Array.isArray(items) ? items.map((entry) => ({
          name: String(entry?.name || 'Ukjent produkt'),
          revenue: Number(entry?.revenue || 0),
          quantity: Number(entry?.quantity ?? entry?.qty ?? 0),
        })) : [];

      const meaningful = processed.filter((entry) => entry.revenue !== 0 || entry.quantity !== 0);

        if (!meaningful.length) {
          setAiProductsStatus(message || 'Ingen data for valgt dato.');
          return;
        }

        setAiProductsStatus(isDemo ? 'Viser demo-data for produktsalget.' : '', isDemo ? 'demo' : '');

        const topItems = [...meaningful]
          .sort((a, b) => {
            if (b.revenue !== a.revenue) return b.revenue - a.revenue;
            return b.quantity - a.quantity;
          })
          .slice(0, 5);

        const bottomItems = [...meaningful]
          .sort((a, b) => {
            if (a.revenue !== b.revenue) return a.revenue - b.revenue;
            return a.quantity - b.quantity;
          })
          .slice(0, 5);

        if (aiTopListEl) {
          topItems.forEach((item) => aiTopListEl.appendChild(buildProductListItem(item)));
        }

        if (aiBottomListEl) {
          bottomItems.forEach((item) => aiBottomListEl.appendChild(buildProductListItem(item)));
        }
      };

      const HOURLY_HOURS = Array.from({ length: 24 }, (_, index) => index);

      const parseHourlySeries = (raw) => {
        if (raw == null) return null;
        const series = Array.from({ length: 24 }, () => 0);
        const parseHour = (hourCandidate, fallbackIndex = null) => {
          if (hourCandidate == null) return fallbackIndex;
          if (typeof hourCandidate === 'number' && Number.isFinite(hourCandidate)) {
            const rounded = Math.floor(hourCandidate);
            return rounded >= 0 && rounded <= 23 ? rounded : fallbackIndex;
          }
          const str = String(hourCandidate).trim();
          if (!str) return fallbackIndex;
          if (/^\d{1,2}$/.test(str)) {
            const num = Number(str);
            return num >= 0 && num <= 23 ? num : fallbackIndex;
          }
          const tIndex = str.indexOf('T');
          if (tIndex !== -1 && str.length >= tIndex + 3) {
            const maybe = Number(str.slice(tIndex + 1, tIndex + 3));
            if (Number.isFinite(maybe) && maybe >= 0 && maybe <= 23) return maybe;
          }
          const colonMatch = str.match(/\b(\d{1,2}):\d{2}\b/);
          if (colonMatch) {
            const maybe = Number(colonMatch[1]);
            if (Number.isFinite(maybe) && maybe >= 0 && maybe <= 23) return maybe;
          }
          return fallbackIndex;
        };
        const assign = (hourCandidate, valueCandidate, fallbackIndex = null) => {
          const hour = parseHour(hourCandidate, fallbackIndex);
          if (hour == null) return;
          const numericValue = Number(valueCandidate);
          if (!Number.isFinite(numericValue) || numericValue < 0) return;
          series[hour] = numericValue;
        };
        if (Array.isArray(raw)) {
          raw.forEach((entry, index) => {
            if (typeof entry === 'number' || typeof entry === 'string') assign(index, entry, index);
            else if (entry && typeof entry === 'object') {
              assign(entry.hour ?? entry.h ?? entry.time ?? entry.timestamp ?? index, entry.value ?? entry.revenue ?? entry.amount ?? entry.total ?? entry.qty ?? 0, index);
            }
          });
        } else if (typeof raw === 'object') {
          Object.entries(raw).forEach(([key, value]) => assign(key, value));
        } else if (typeof raw === 'number' || typeof raw === 'string') {
          assign(0, raw);
        }
        const hasValues = series.some((value) => Number(value || 0) > 0);
        return hasValues ? series : null;
      };

      Object.entries(defaultHourlySeriesSeeds).forEach(([seedIso, seedSeries]) => {
        const parsedSeed = parseHourlySeries(seedSeries);
        if (parsedSeed) hourlySeriesCache.set(seedIso, parsedSeed);
      });

      const hourlySeriesTotal = (series) => {
        if (!Array.isArray(series)) return 0;
        return series.reduce((sum, value) => sum + (Number(value) || 0), 0);
      };

      const pickSeriesFocusHour = (series) => {
        if (!Array.isArray(series) || !series.length) return 17;
        for (let hour = series.length - 1; hour >= 0; hour -= 1) {
          if (Number(series[hour] || 0) > 0) return hour;
        }
        let maxIndex = 0;
        let maxValue = -Infinity;
        series.forEach((value, index) => {
          if (Number(value) > maxValue) {
            maxValue = Number(value);
            maxIndex = index;
          }
        });
        return maxIndex;
      };

      const getSeriesBounds = (series) => {
        if (!Array.isArray(series) || !series.length) return { start: null, end: null };
        let start = series.findIndex((value) => Number(value || 0) > 0);
        if (start === -1) start = null;
        let end = null;
        for (let index = series.length - 1; index >= 0; index -= 1) {
          if (Number(series[index] || 0) > 0) {
            end = index;
            break;
          }
        }
        return { start, end };
      };

      const formatHourLabel = (hour) => {
        const safeHour = Math.max(0, Math.min(23, Number(hour) || 0));
        return `kl ${String(safeHour).padStart(2, '0')}`;
      };

      const drawHourlyChart = (state) => {
        if (!hourlyCanvas || !hourlyCardEl) return;
        const ctx = hourlyCanvas.getContext('2d');
        if (!ctx) return;
        const width = hourlyCanvas.clientWidth || 800;
        const height = hourlyCanvas.clientHeight || 280;
        const dpr = window.devicePixelRatio || 1;
        hourlyCanvas.width = width * dpr;
        hourlyCanvas.height = height * dpr;
        ctx.save();
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);

        const padding = { top: 20, right: 24, bottom: 60, left: 72 };
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;
        state.layout = { padding, chartWidth, width, height };

        const themeRoot = document.body || document.documentElement;
        const styles = window.getComputedStyle(themeRoot);
        const chartPanelTop = styles.getPropertyValue('--chart-panel-top').trim() || 'rgba(20,34,62,0.85)';
        const chartPanelBottom = styles.getPropertyValue('--chart-panel-bottom').trim() || 'rgba(7,11,20,0.85)';
        const chartGridColor = styles.getPropertyValue('--chart-grid').trim() || 'rgba(255,255,255,0.08)';
        const chartGridStrong = styles.getPropertyValue('--chart-grid-strong').trim() || 'rgba(255,255,255,0.12)';
        const axisLabelColor = styles.getPropertyValue('--text-soft').trim() || 'rgba(232,235,244,0.65)';

        const allValues = [...state.current, ...(state.comparison || [])];
        const boundsList = [state.current, state.comparison]
          .map(getSeriesBounds)
          .filter((bounds) => bounds.start != null);
        let startHour = boundsList.length ? Math.min(...boundsList.map((b) => b.start)) : 0;
        let endHour = boundsList.length ? Math.max(...boundsList.map((b) => b.end)) : 23;
        const preferredHourStart = 9;
        const preferredHourEnd = 19;
        if (!Number.isFinite(startHour)) startHour = preferredHourStart;
        if (!Number.isFinite(endHour) || endHour < startHour) endHour = preferredHourEnd;
        startHour = preferredHourStart;
        endHour = Math.max(endHour, preferredHourEnd);
        if (endHour - startHour < 2) endHour = Math.min(23, startHour + 2);
        const hourSpan = Math.max(1, endHour - startHour);
        state.startHour = startHour;
        state.endHour = endHour;
        state.hourSpan = hourSpan;

        let maxValue = Math.max(10, ...allValues);
        const niceStep = (() => {
          if (maxValue <= 5000) return 1000;
          if (maxValue <= 8000) return 2000;
          if (maxValue <= 12000) return 2500;
          if (maxValue <= 20000) return 5000;
          return 10000;
        })();
        const totalSteps = Math.max(4, Math.ceil(maxValue / niceStep));
        maxValue = totalSteps * niceStep;

        const getPoint = (hourIndex, value) => {
          const clamped = Math.min(Math.max(hourIndex, startHour), endHour);
          const relative = (clamped - startHour) / hourSpan;
          const x = padding.left + relative * chartWidth;
          const y = padding.top + chartHeight - (value / maxValue) * chartHeight;
          return [x, y];
        };

        const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight);
        gradient.addColorStop(0, chartPanelTop);
        gradient.addColorStop(1, chartPanelBottom);
        ctx.fillStyle = gradient;
        ctx.fillRect(padding.left, padding.top, chartWidth, chartHeight);

        ctx.strokeStyle = chartGridColor;
        ctx.lineWidth = 1;
        for (let value = 0; value <= maxValue; value += niceStep) {
          const y = padding.top + chartHeight - (value / maxValue) * chartHeight;
          ctx.beginPath();
          ctx.moveTo(padding.left, y);
          ctx.lineTo(padding.left + chartWidth, y);
          ctx.stroke();
          ctx.fillStyle = axisLabelColor;
          ctx.font = '11px/1 "Inter",system-ui,sans-serif';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          if (value === 0) {
            ctx.fillText('0 kr', padding.left - 10, y);
          } else {
            const label = value >= 1000
              ? `${Math.round(value / 1000)} 000 kr`
              : moneyFmt.format(value).replace(/\sNOK/, '');
            ctx.fillText(label, padding.left - 10, y);
          }
        }
        ctx.strokeStyle = chartGridStrong;
        const desiredLabels = chartWidth > 600 ? 10 : 6;
        const hourLabelStep = Math.max(1, Math.ceil(hourSpan / desiredLabels));
        for (let hour = startHour; hour <= endHour; hour += hourLabelStep) {
          const [x] = getPoint(hour, 0);
          ctx.beginPath();
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, padding.top + chartHeight);
          ctx.stroke();
          ctx.fillStyle = axisLabelColor;
          ctx.font = '11px/1 "Inter",system-ui,sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(formatHourLabel(hour).replace('kl ', ''), x, padding.top + chartHeight + 10);
        }
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';

        const drawSeries = (series, { color, width: lineWidth = 2, dash = [], pointFill = color, pointStroke = '#0d1b2e' }) => {
          if (!Array.isArray(series)) return;
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(dash);
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          let started = false;
          ctx.beginPath();
          for (let index = startHour; index <= endHour; index += 1) {
            const numeric = Number(series[index] || 0);
            const [x, y] = getPoint(index, numeric);
            if (!started) {
              ctx.moveTo(x, y);
              started = true;
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
          ctx.setLineDash([]);
          series.forEach((value, index) => {
            if (index < startHour || index > endHour) return;
            const numeric = Number(value) || 0;
            if (numeric <= 0) return;
            const [x, y] = getPoint(index, numeric);
            ctx.beginPath();
            ctx.arc(x, y, index === state.focusHour ? 5 : 4, 0, Math.PI * 2);
            ctx.fillStyle = pointFill;
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = pointStroke;
            ctx.stroke();
          });
      ctx.restore();
    };

      const handleHourlyPointer = (event) => {
        if (!hourlyCanvas || !hourlyChartState?.layout) return;
        const { padding, chartWidth } = hourlyChartState.layout;
        const rect = hourlyCanvas.getBoundingClientRect();
        const client = event.touches ? event.touches[0] : event;
        if (!client) return;
        const pointerX = client.clientX - rect.left;
        const relativeX = pointerX - padding.left;
        if (relativeX < 0 || relativeX > chartWidth) return;
        const ratio = relativeX / chartWidth;
        const startHour = hourlyChartState.startHour ?? 0;
        const span = hourlyChartState.hourSpan ?? (HOURLY_HOURS.length - 1);
        const hour = Math.round(startHour + ratio * span);
        setHourlyFocusHour(hour);
        if (event.type === 'touchmove') event.preventDefault();
      };

      const handleHourlyPointerLeave = () => {
        setHourlyFocusHour(null);
      };

      const registerHourlyCanvasEvents = () => {
        if (!hourlyCanvas || hourlyCanvas.dataset.interactive === '1') return;
        hourlyCanvas.addEventListener('mousemove', handleHourlyPointer);
        hourlyCanvas.addEventListener('click', handleHourlyPointer);
        hourlyCanvas.addEventListener('mouseleave', handleHourlyPointerLeave);
        hourlyCanvas.addEventListener('touchmove', handleHourlyPointer, { passive: false });
        hourlyCanvas.addEventListener('touchend', handleHourlyPointerLeave);
        hourlyCanvas.dataset.interactive = '1';
      };
      registerHourlyCanvasEvents();

        drawSeries(state.comparison, {
          color: 'rgba(255,255,255,0.32)',
          lineWidth: 2,
          dash: [6, 6],
          pointFill: 'rgba(255,255,255,0.45)',
          pointStroke: 'rgba(9,14,24,0.6)',
        });
        drawSeries(state.current, {
          color: '#4fa7ff',
          lineWidth: 2.6,
          pointFill: '#4fa7ff',
          pointStroke: 'rgba(8,13,24,0.85)',
        });

        ctx.restore();
      };

      const updateHourlyFocus = (state) => {
        if (!hourlyCardEl) return;
        const focusHour = Math.max(0, Math.min(23, state.focusHour ?? pickSeriesFocusHour(state.current || [])));
        const currentValue = state.current?.[focusHour] || 0;
        const previousValue = state.comparison?.[focusHour] || 0;
        const delta = previousValue > 0 ? (currentValue - previousValue) / previousValue : null;

        if (hourlyFocusLabelEl) {
          hourlyFocusLabelEl.textContent = `${formatFriendlyDate(state.date)} ${formatHourLabel(focusHour)}`;
        }
        if (hourlyFocusCurrentEl) {
          hourlyFocusCurrentEl.textContent = moneyFmt.format(currentValue);
        }
        if (hourlyFocusPreviousEl) {
          hourlyFocusPreviousEl.textContent = previousValue > 0 ? moneyFmt.format(previousValue) : '';
        }
        if (hourlyFocusDeltaEl) {
          hourlyFocusDeltaEl.textContent = delta != null ? formatSignedPercent(delta) : '';
        }

        if (hourlyTagEl) {
          const cutoff = 15;
          const sliceCurrent = (state.current || []).slice(0, cutoff).reduce((sum, value) => sum + Number(value || 0), 0);
          const slicePrev = (state.comparison || []).slice(0, cutoff).reduce((sum, value) => sum + Number(value || 0), 0);
          const sliceDelta = slicePrev > 0 ? (sliceCurrent - slicePrev) / slicePrev : null;
          if (sliceDelta != null) {
            hourlyTagEl.textContent = `Fr ${formatHourLabel(cutoff)} ${formatSignedPercent(sliceDelta)}`;
            hourlyCardEl.dataset.tone = sliceDelta >= 0 ? 'positive' : 'negative';
          } else {
            hourlyTagEl.textContent = 'Ingen trenddata';
            hourlyCardEl.removeAttribute('data-tone');
          }
        }

        if (hourlyNoteEl) {
          const totalCurrent = hourlySeriesTotal(state.current);
          const totalPrev = hourlySeriesTotal(state.comparison);
          if (totalPrev > 0) {
            const diff = totalCurrent - totalPrev;
            const pct = diff / totalPrev;
            hourlyNoteEl.textContent = `Totalt ${moneyFmt.format(totalCurrent)} (${formatSignedPercent(pct)} vs forrige uke)`;
          } else if (totalCurrent > 0) {
            hourlyNoteEl.textContent = `Totalt ${moneyFmt.format(totalCurrent)} i dag.`;
          } else {
            hourlyNoteEl.textContent = 'Ingen timetall for valgt dato.';
          }
          if (state.isDemo && hourlyNoteEl.textContent) {
            hourlyNoteEl.textContent = `${hourlyNoteEl.textContent}  demo`;
          }
        }
      };

      const renderHourlyInsights = ({ date, isDemo = false } = {}) => {
        if (!hourlyCardEl) return;
        const iso = sanitizeIso(date);
        const currentSeries = hourlySeriesCache.get(iso);
        const comparisonIso = iso ? sanitizeIso(shiftIsoDate(iso, -7)) : null;
        if (comparisonIso && hourlySeedDates.has(comparisonIso) && hourlySeriesCache.has(comparisonIso)) {
          syncHourlyPayload({ iso: comparisonIso, comparison: true });
        }
        const comparisonSeries = comparisonIso ? hourlySeriesCache.get(comparisonIso) : null;
        hourlyCardEl.hidden = false;
        const safeSeries = Array.isArray(currentSeries) ? currentSeries : Array.from({ length: 24 }, () => 0);
        const hasCurrentData = Array.isArray(currentSeries) && currentSeries.some((value) => Number(value || 0) > 0);
        if (hourlyEmptyEl) {
          if (hasCurrentData) {
            hourlyEmptyEl.hidden = true;
            hourlyEmptyEl.style.display = 'none';
          } else {
            hourlyEmptyEl.hidden = false;
            hourlyEmptyEl.style.display = 'flex';
          }
        }
        const defaultFocusHour = pickSeriesFocusHour(safeSeries);
        const demoFlag = isDemo || hourlySeedDates.has(iso);
        hourlyChartState = {
          date: iso,
          current: safeSeries,
          comparison: comparisonSeries,
          compareIso: comparisonIso,
          focusHour: defaultFocusHour,
          defaultFocusHour,
          isDemo: demoFlag,
          layout: null,
        };
        drawHourlyChart(hourlyChartState);
        updateHourlyFocus(hourlyChartState);
     };

      const ingestHourlySeries = (hourlyMap = {}) => {
        if (!hourlyMap || typeof hourlyMap !== 'object') return;
        Object.entries(hourlyMap).forEach(([key, rawSeries]) => {
          const iso = sanitizeIso(key);
          const parsed = parseHourlySeries(rawSeries);
          if (iso && parsed) {
            hourlySeriesCache.set(iso, parsed);
            hourlySeedDates.delete(iso);
          }
        });
      };

      const syncHourlyPayload = ({
        iso,
        revenue,
        hourlySeries,
        hourlyByDay,
        comparison = false,
      } = {}) => {
        if (hourlyByDay && typeof hourlyByDay === 'object' && Object.keys(hourlyByDay).length) {
          ingestHourlySeries(hourlyByDay);
        }
        const key = sanitizeIso(iso);
        if (!key) return;
        if (hourlySeries) {
          const parsed = parseHourlySeries(hourlySeries);
          if (parsed) {
            hourlySeriesCache.set(key, parsed);
            hourlySeedDates.delete(key);
          }
        }
        const hasSeries = hourlySeriesCache.has(key);
        const previewRevenue = PREVIEW_DAY_TOTALS[key]?.revenue;
        const targetRevenue = Number(revenue || previewRevenue || 0);
        if (targetRevenue > 0) {
          scaleHourlySeriesToTotal(key, targetRevenue, { comparison });
        } else if (hasSeries) {
          refreshHourlyChartSeries(key, { comparison });
        }
      };

      window.addEventListener('resize', () => {
        if (hourlyChartState) drawHourlyChart(hourlyChartState);
      });

      const getDailyEntry = (iso, fallback = []) => {
        if (!iso) return null;
        const fromChart = chartDataMap.get(iso);
        if (fromChart) return fromChart;
        return fallback.find((entry) => entry?.date === iso) || null;
      };

      const getMonthEntries = (iso, fallback = []) => {
        const parsed = parseIsoDate(iso);
        if (!parsed) return [];
        const year = parsed.getFullYear();
        const month = parsed.getMonth();
        const matches = (entry) => {
          const entryDate = parseIsoDate(entry?.date);
          return entryDate && entryDate.getFullYear() === year && entryDate.getMonth() === month && Number.isFinite(entry?.revenue);
        };
        const fromChart = chartDataAll.filter(matches);
        if (fromChart.length) return fromChart;
        return fallback.filter(matches);
      };

      const renderRevenueAnalysisState = (state, { message = '', date } = {}) => {
        if (!revenueCardEl) return;
        if (revenueDateEl) revenueDateEl.textContent = date ? formatFriendlyDate(date) : '';
        if (state === 'loading' && revenueComparisonEl) revenueComparisonEl.textContent = '';
        if (state === 'loading') {
          revenueCurrentEl && (revenueCurrentEl.textContent = '');
          revenueWeekDeltaEl && (revenueWeekDeltaEl.textContent = '');
          revenueMonthDeltaEl && (revenueMonthDeltaEl.textContent = '');
          setDeltaTone(revenueWeekDeltaEl, NaN);
          setDeltaTone(revenueMonthDeltaEl, NaN);
          if (revenueCurrentNoteEl) revenueCurrentNoteEl.textContent = '';
          if (revenueWeekNoteEl) { revenueWeekNoteEl.textContent = 'Henter referanse '; setDeltaTone(revenueWeekNoteEl, NaN); }
          if (revenueMonthNoteEl) { revenueMonthNoteEl.textContent = 'Henter mnedsdata '; setDeltaTone(revenueMonthNoteEl, NaN); }
          if (revenueStatusEl) revenueStatusEl.textContent = message || 'Analyserer omsetningen ';
          return;
        }
        if (state === 'error') {
          if (revenueComparisonEl) revenueComparisonEl.textContent = '';
          if (revenueStatusEl) revenueStatusEl.textContent = message || 'Kunne ikke hente omsetningsanalyse.';
          return;
        }
        if (revenueStatusEl) revenueStatusEl.textContent = message || '';
      };

      const renderRevenueAnalysis = ({ date, fallbackDaily = [], entry = null } = {}) => {
        revenueAnalysisContext = { date, fallbackDaily, entry };
        if (!revenueCardEl) return;
        const iso = sanitizeIso(date);
        renderRevenueAnalysisState('ready', { date: iso });
        if (!iso) {
          if (revenueStatusEl) revenueStatusEl.textContent = 'Velg en dato for  se omsetningen.';
          return;
        }

        const currentEntry = entry || getDailyEntry(iso, fallbackDaily);
        if (!currentEntry) {
          renderRevenueAnalysisState('error', { date: iso, message: 'Ingen omsetning registrert for valgt dato.' });
          return;
        }

        const currentRevenue = Number(currentEntry.revenue || 0);
        const currentReceipts = Number(currentEntry.receipts || 0);
        if (revenueCurrentEl) revenueCurrentEl.textContent = moneyFmt.format(currentRevenue);
        if (revenueCurrentNoteEl) {
          revenueCurrentNoteEl.textContent = currentReceipts > 0 ? `${qtyFmt.format(currentReceipts)} kvitteringer` : '';
        }

        const prevIso = sanitizeIso(shiftIsoDate(iso, -7));
        if (revenueComparisonEl) {
          revenueComparisonEl.textContent = prevIso ? `Referanse: ${formatFriendlyDate(prevIso)}` : 'Ingen referanse 7 dager tidligere';
        }
        const prevEntry = prevIso ? getDailyEntry(prevIso, fallbackDaily) : null;
        if (prevEntry && Number.isFinite(prevEntry.revenue)) {
          const prevRevenue = Number(prevEntry.revenue || 0);
          const diff = currentRevenue - prevRevenue;
          const pct = prevRevenue > 0 ? diff / prevRevenue : null;
          if (revenueWeekDeltaEl) {
            revenueWeekDeltaEl.textContent = formatSignedPercent(pct) || formatSignedCurrency(diff);
            setDeltaTone(revenueWeekDeltaEl, diff);
          }
          if (revenueWeekNoteEl) {
            const parts = [moneyFmt.format(prevRevenue)];
            if (currentReceipts > 0 && Number.isFinite(prevEntry.receipts)) {
              parts.push(`${qtyFmt.format(prevEntry.receipts)} kvitt.`);
            }
            revenueWeekNoteEl.textContent = `Forrige uke: ${parts.join('  ')}`;
            setDeltaTone(revenueWeekNoteEl, diff);
          }
        } else {
          if (revenueWeekDeltaEl) {
            revenueWeekDeltaEl.textContent = '';
            setDeltaTone(revenueWeekDeltaEl, NaN);
          }
          if (revenueWeekNoteEl) {
            revenueWeekNoteEl.textContent = 'Ingen tall 7 dager tilbake.';
            setDeltaTone(revenueWeekNoteEl, NaN);
          }
        }

        const monthEntries = getMonthEntries(iso, fallbackDaily).filter((item) => Number.isFinite(item?.revenue));
        if (monthEntries.length) {
          const total = monthEntries.reduce((sum, item) => sum + Number(item.revenue || 0), 0);
          const monthAverage = monthEntries.length ? total / monthEntries.length : 0;
          const diffMonth = currentRevenue - monthAverage;
          const pctMonth = monthAverage > 0 ? diffMonth / monthAverage : null;
          if (revenueMonthDeltaEl) {
            revenueMonthDeltaEl.textContent = formatSignedPercent(pctMonth) || formatSignedCurrency(diffMonth);
            setDeltaTone(revenueMonthDeltaEl, diffMonth);
          }
          if (revenueMonthNoteEl) {
            revenueMonthNoteEl.textContent = `Mnedssnitt: ${moneyFmt.format(monthAverage)} (${monthEntries.length} dager)`;
            setDeltaTone(revenueMonthNoteEl, diffMonth);
          }
        } else {
          if (revenueMonthDeltaEl) {
            revenueMonthDeltaEl.textContent = '';
            setDeltaTone(revenueMonthDeltaEl, NaN);
          }
          if (revenueMonthNoteEl) {
            revenueMonthNoteEl.textContent = 'Manglende mnedsdata for  beregne snitt.';
            setDeltaTone(revenueMonthNoteEl, NaN);
          }
        }

        if (revenueStatusEl) revenueStatusEl.textContent = '';
      };

      const renderProductChangesState = (state, { date, compareDate, message = '', isDemo = false } = {}) => {
        if (!productChangeCardEl) return;
        if (productChangeDateEl) productChangeDateEl.textContent = date ? formatFriendlyDate(date) : '';
        if (productChangeCompareEl) productChangeCompareEl.textContent = compareDate ? `Mot ${formatFriendlyDate(compareDate)}` : '';
        if (productChangeUpEl) productChangeUpEl.innerHTML = '';
        if (productChangeDownEl) productChangeDownEl.innerHTML = '';
        if (state === 'loading') {
          if (productChangeStatusEl) productChangeStatusEl.textContent = message || 'Analyserer salgsendringer ';
          return;
        }
        if (state === 'error') {
          if (productChangeStatusEl) productChangeStatusEl.textContent = message || 'Kunne ikke beregne endringer.';
          return;
        }
        if (productChangeStatusEl) {
          productChangeStatusEl.textContent = message || (isDemo ? 'Viser demo-data for produktendringer.' : '');
        }
      };

      const renderProductChanges = ({ date, compareDate, currentItems = [], previousItems = [], isDemo = false }) => {
        if (!productChangeCardEl) return;
        renderProductChangesState('ready', { date, compareDate, isDemo });
        const { increases, decreases } = computeProductChanges(currentItems, previousItems);
        const hasIncreases = increases.length > 0;
        const hasDecreases = decreases.length > 0;

        if (!hasIncreases && !hasDecreases) {
          renderProductChangesState('error', { date, compareDate, message: 'Ingen endringer i salg mot forrige uke.' });
          return;
        }

        if (productChangeUpEl) {
          const topUps = increases.slice(0, 5);
          if (topUps.length) {
            topUps.forEach((entry) => {
              productChangeUpEl.appendChild(buildProductChangeItem(entry, { compareLabel: compareDate }));
            });
          } else {
            const li = document.createElement('li');
            li.className = 'product-change-card__item';
            li.textContent = 'Ingen produkter kte salget vs forrige uke.';
            productChangeUpEl.appendChild(li);
          }
        }

        if (productChangeDownEl) {
          const topDowns = decreases.slice(0, 5);
          if (topDowns.length) {
            topDowns.forEach((entry) => {
              productChangeDownEl.appendChild(buildProductChangeItem(entry, { compareLabel: compareDate }));
            });
          } else {
            const li = document.createElement('li');
            li.className = 'product-change-card__item';
            li.textContent = 'Ingen produkter falt i salg vs forrige uke.';
            productChangeDownEl.appendChild(li);
          }
        }
      };

      const pickItemsFromResponse = (data) => {
        if (!data) return [];
        if (Array.isArray(data.items)) return data.items;
        if (Array.isArray(data.top)) return data.top;
        if (Array.isArray(data.records)) return data.records;
        return [];
      };

      const loadProductChanges = ({ date, items = [], options = {}, isDemo = false }) => {
        if (!productChangeCardEl) return;
        const iso = sanitizeIso(date);
        const compareIso = iso ? sanitizeIso(shiftIsoDate(iso, -7)) : null;
        renderProductChangesState('loading', { date: iso, compareDate: compareIso });
        productChangeContext = { date: iso, items, options, isDemo };

        if (!iso) {
          renderProductChangesState('error', { date: iso, compareDate: compareIso, message: 'Velg en dato for  se endringer.' });
          return;
        }
        if (!Array.isArray(items) || !items.length) {
          renderProductChangesState('error', { date: iso, compareDate: compareIso, message: 'Ingen produktsalg for datoen.' });
          return;
        }
        if (!compareIso) {
          renderProductChangesState('error', { date: iso, compareDate: compareIso, message: 'Manglet referanse 7 dager tilbake.' });
          return;
        }

        const applyResult = (previousItems, compareIsDemo = false) => {
          if (productChangeContext.date !== iso) return;
          renderProductChanges({
            date: iso,
            compareDate: compareIso,
            currentItems: items,
            previousItems,
            isDemo: isDemo || compareIsDemo,
          });
        };

        const hydrateComparisonHourly = (payload, { isDemo: comparisonIsDemo = false } = {}) => {
          if (!payload || !compareIso) return;
          const compareDay = payload.dayTotal && sanitizeIso(payload.dayTotal.date) === compareIso
            ? payload.dayTotal
            : (Array.isArray(payload.daily) ? payload.daily.find((entry) => entry?.date === compareIso) : null);
          const compareEntry = mergePreviewDayTotals(compareDay, compareIso, { enabled: comparisonIsDemo });
          syncHourlyPayload({
            iso: compareIso,
            revenue: compareEntry?.revenue,
            hourlySeries: compareEntry?.hourly,
            hourlyByDay: payload?.hourlyByDay,
            comparison: true,
          });
        };

        const handleError = (error) => {
          if (productChangeContext.date !== iso) return;
          renderProductChangesState('error', {
            date: iso,
            compareDate: compareIso,
            message: error?.body?.message || error?.message || 'Kunne ikke hente referansesalget.',
          });
        };

        fetchDayTotals(compareIso, options)
          .then((data) => {
            const compareIsDemo = !!options.demo || data?.mode === 'demo';
            hydrateComparisonHourly(data, { isDemo: compareIsDemo });
            const previousItems = pickItemsFromResponse(data);
            applyResult(previousItems, compareIsDemo);
          })
          .catch((error) => {
            const shouldDemo = !options.demo && error?.status === 400 &&
              (error?.body?.error === 'CONFIG_MISSING' || error?.body?.error === 'RECEIPTS_FAIL');
            if (shouldDemo) {
              fetchDayTotals(compareIso, { demo: true })
                .then((demoData) => {
                  hydrateComparisonHourly(demoData, { isDemo: true });
                  const previousItems = pickItemsFromResponse(demoData);
                  applyResult(previousItems, true);
                })
                .catch(handleError);
              return;
            }
            handleError(error);
          });
      };

      const hideGlobalTooltip = () => {
        if (!chartTooltip) return;
        chartTooltip.dataset.visible = '0';
        chartTooltip.hidden = true;
      };

      const defaultDayStatus = 'Henter omsetning ';

      const loadBalanceCard = () => {
        if (!chartBalanceValueEl && !highlightBankValueEl && !highlightNetValueEl) return;
        if (typeof fetch !== 'function') {
          if (chartBalanceStatusEl) {
            chartBalanceStatusEl.textContent = 'Nettleseren sttter ikke datahenting.';
            chartBalanceStatusEl.dataset.tone = 'error';
          }
          if (highlightBankMetaEl) {
            highlightBankMetaEl.textContent = 'Nettleseren sttter ikke datahenting.';
          }
          return;
        }
        if (chartBalanceValueEl) {
          chartBalanceValueEl.textContent = '';
          chartBalanceValueEl.classList.remove('positive', 'negative');
        }
        if (chartBalanceStatusEl) {
          chartBalanceStatusEl.textContent = 'Henter saldo ';
          chartBalanceStatusEl.dataset.tone = 'muted';
        }
        if (highlightBankValueEl) {
          highlightBankValueEl.textContent = '';
          highlightBankValueEl.classList.remove('positive', 'negative');
        }
        if (highlightBankMetaEl) highlightBankMetaEl.textContent = 'Henter saldo ';
        const yearStartISO = `${today.getFullYear()}-01-01`;
        const url = new URL('/.netlify/functions/tripletex', window.location.origin);
        url.searchParams.set('from', yearStartISO);
        url.searchParams.set('to', todayISO);
        url.searchParams.set('accounts', 'balanceOperating|Saldo Driftskonto:id-289892105');
        fetch(url.toString(), { headers: { accept: 'application/json' } })
          .then(async (response) => {
            const payload = await response.json().catch(() => null);
            if (!response.ok) {
              const friendly = payload?.message ||
                payload?.developerMessage ||
                (typeof payload?.error === 'string' ? payload.error : '') ||
                (response.status === 401 ? 'Mangler tilgang til Tripletex. Sjekk API-innloggingen.' : `HTTP ${response.status}`);
              const err = new Error(friendly || 'Kunne ikke hente saldo');
              err.status = response.status;
              err.payload = payload;
              throw err;
            }
            const entry = Array.isArray(payload?.accounts)
              ? payload.accounts.find((item) => item.key === 'balanceOperating')
              : null;
            if (!entry) throw new Error('Fant ikke driftskontoen i Tripletex-responsen.');
            const balance = Number(entry.total ?? entry.totalAbsolute ?? 0);
            latestBankBalance = balance;
            if (chartBalanceValueEl) {
              chartBalanceValueEl.textContent = moneyFmt.format(balance);
              chartBalanceValueEl.classList.remove('positive', 'negative');
              if (balance > 0) chartBalanceValueEl.classList.add('positive');
              if (balance < 0) chartBalanceValueEl.classList.add('negative');
            }
            if (chartBalanceStatusEl) {
              chartBalanceStatusEl.textContent = '';
              chartBalanceStatusEl.dataset.tone = 'muted';
            }
            if (highlightBankValueEl) {
              highlightBankValueEl.textContent = moneyFmt.format(balance);
              highlightBankValueEl.classList.remove('positive', 'negative');
              if (balance > 0) highlightBankValueEl.classList.add('positive');
              if (balance < 0) highlightBankValueEl.classList.add('negative');
            }
            if (highlightBankMetaEl) highlightBankMetaEl.textContent = '';
            updateNetHighlight();
          })
          .catch((error) => {
        console.error('Kunne ikke hente saldo for driftskonto:', error);
            if (chartBalanceValueEl) {
              chartBalanceValueEl.textContent = '';
              chartBalanceValueEl.classList.remove('positive', 'negative');
            }
            if (chartBalanceStatusEl) {
              const friendly = error?.message || 'Kunne ikke hente saldo';
              chartBalanceStatusEl.textContent = friendly;
              chartBalanceStatusEl.dataset.tone = 'error';
            }
            if (highlightBankValueEl) {
              highlightBankValueEl.textContent = '';
              highlightBankValueEl.classList.remove('positive', 'negative');
            }
            if (highlightBankMetaEl) {
              if (error?.status === 401) {
                highlightBankMetaEl.textContent = 'Mangler tilgang til Tripletex  sjekk API-nkkel/bruker.';
              } else {
                highlightBankMetaEl.textContent = error?.message || 'Kunne ikke hente saldo';
              }
            }
            updateNetHighlight();
          });
      };

      loadBalanceCard();

      const renderDayTotals = ({ date, revenue, receipts, guests }, { isDemo = false, suppressStatus = false, cache = true } = {}) => {
        if (!dayRevenueEl) return;
        const parsed = date ? new Date(`${date}T00:00:00`) : null;
        const friendly = parsed && !Number.isNaN(parsed.getTime()) ? dateFmtLong.format(parsed) : date || '';
        const revenueValue = Number(revenue || 0);
        const receiptsValue = Number(receipts || 0);
        const averageSale = receiptsValue > 0 ? revenueValue / receiptsValue : null;
        dayRevenueEl.textContent = moneyFmt.format(revenueValue);
        dayRevenueEl.classList.remove('positive', 'negative');
        if (revenueValue > 0) dayRevenueEl.classList.add('positive');
        if (revenueValue < 0) dayRevenueEl.classList.add('negative');
        scaleHourlySeriesToTotal(date, revenueValue, { comparison: false });
        if (dayAverageEl) {
          dayAverageEl.textContent = averageSale != null ? moneyFmt.format(averageSale) : '';
        }
        if (!suppressStatus && dayStatusEl) {
          dayStatusEl.textContent = '';
          dayStatusEl.dataset.tone = 'muted';
        }
        if (dayReceiptsValueEl) {
          dayReceiptsValueEl.textContent = receiptsValue > 0 ? qtyFmt.format(receiptsValue) : '0';
        }
        if (dayReceiptsStatusEl) {
          dayReceiptsStatusEl.textContent = receiptsValue > 0 ? '' : 'Ingen kvitteringer registrert';
          dayReceiptsStatusEl.dataset.tone = receiptsValue > 0 ? 'muted' : 'warning';
        }
        if (dayAverageStatusEl) {
          dayAverageStatusEl.textContent = receiptsValue > 0 ? '' : 'Ingen kvitteringer';
          dayAverageStatusEl.dataset.tone = receiptsValue > 0 ? 'muted' : 'warning';
        }
        if (dayWeekDeltaBadgeEl) {
          const prevDate = sanitizeIso(shiftIsoDate(date, -7));
          const prevEntry = prevDate ? getDailyEntry(prevDate, revenueAnalysisContext.fallbackDaily || []) : null;
          const prevRevenue = Number(prevEntry?.revenue || 0);
          if (prevRevenue > 0 && revenueValue > 0) {
            const delta = ((revenueValue - prevRevenue) / prevRevenue) || 0;
            const formatted = percentFmt.format(delta);
            dayWeekDeltaBadgeEl.textContent = `${formatted} vs forrige uke`;
            dayWeekDeltaBadgeEl.classList.toggle('trend-positive', delta >= 0);
            dayWeekDeltaBadgeEl.classList.toggle('trend-negative', delta < 0);
          } else {
            dayWeekDeltaBadgeEl.textContent = '';
            dayWeekDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
          }
        }
        if (cache) {
          lastDayTotals = { date, revenue: revenueValue, receipts: receiptsValue, isDemo };
        }
      };

      const fetchDayTotals = (date, { demo = false } = {}) => {
        const url = new URL('/.netlify/functions/lightspeed', apiBase);
        url.searchParams.set('date', date);
        url.searchParams.set('limit', '50');
        url.searchParams.set('cache', '1');
        if (demo) url.searchParams.set('demo', '1');
        return fetch(url.toString(), { headers: { accept: 'application/json' } })
          .then(async (response) => {
            const payload = await response.json().catch(() => null);
            if (!response.ok) {
              const error = new Error(`HTTP ${response.status}`);
              error.status = response.status;
              error.body = payload;
              throw error;
            }
            return payload;
          });
      };

      const loadDayTotals = (date) => {
        if (!dayRevenueEl) return;
        if (aiProductsPicker && aiProductsPicker.value !== date) {
          aiProductsPicker.value = date;
        }
        dayRevenueEl.textContent = '';
        if (dayAverageEl) dayAverageEl.textContent = '';
        renderDayStatus(defaultDayStatus);
        if (dayReceiptsStatusEl) {
          dayReceiptsStatusEl.textContent = 'Henter ';
          dayReceiptsStatusEl.dataset.tone = 'muted';
        }
        if (dayReceiptsValueEl) dayReceiptsValueEl.textContent = '';
        if (dayAverageStatusEl) {
          dayAverageStatusEl.textContent = 'Henter ';
          dayAverageStatusEl.dataset.tone = 'muted';
        }
        if (dayWeekDeltaBadgeEl) {
          dayWeekDeltaBadgeEl.textContent = '';
          dayWeekDeltaBadgeEl.classList.remove('trend-positive', 'trend-negative');
        }
        hourlyChartState = null;
        if (hourlyCardEl) {
          hourlyCardEl.hidden = false;
          hourlyCardEl.removeAttribute('data-tone');
          renderHourlyInsights({ date, isDemo: hourlySeedDates.has(date) });
        }
        renderProductInsights(null, { date, state: 'loading' });
        renderRevenueAnalysisState('loading', { date });
        renderProductChangesState('loading', { date });
        revenueAnalysisContext = { date, fallbackDaily: [], entry: null };
        productChangeContext = { date, items: [], options: {}, isDemo: false };

        let attemptedDemo = false;

        const attempt = (options = {}) => {
          fetchDayTotals(date, options)
            .then((data) => {
              const isDemo = !!options.demo || data?.mode === 'demo';
              let effectiveDate = date;
              if (data?.mode === 'cached' && data?.resolvedDate && sanitizeIso(data.resolvedDate)) {
                if (data.resolvedDate !== date) {
                  effectiveDate = data.resolvedDate;
                  activeDateISO = updateSelectedDateUI(effectiveDate);
                }
              }
              const items = Array.isArray(data?.items) ? data.items : Array.isArray(data?.top) ? data.top : [];
              let selected = data?.dayTotal || null;
              const daily = Array.isArray(data?.daily) ? data.daily : [];
              if (!selected && daily.length) {
                selected = daily.find((d) => d.date === effectiveDate) || daily[0];
              }
              const selectedIso = sanitizeIso(selected?.date);
              if (selectedIso && selectedIso !== effectiveDate) {
                effectiveDate = selectedIso;
                activeDateISO = updateSelectedDateUI(effectiveDate);
              }
              if (selected && selectedIso && selected.date !== selectedIso) {
                selected = { ...selected, date: selectedIso };
              }
              if (selected) {
                selected = mergePreviewDayTotals(selected, null, { enabled: isDemo });
                renderDayTotals(selected, { isDemo });
              } else {
                renderDayStatus('Ingen omsetning funnet for valgt dato.', 'warning');
          if (dayReceiptsStatusEl) {
            dayReceiptsStatusEl.textContent = 'Ingen kvitteringer';
            dayReceiptsStatusEl.dataset.tone = 'warning';
          }
        }
              renderProductInsights(items, { date: effectiveDate, isDemo, message: 'Ingen data for valgt dato.' });
              revenueAnalysisContext = { date: effectiveDate, fallbackDaily: daily, entry: selected };
              renderRevenueAnalysis(revenueAnalysisContext);
              updateDayWeekDeltaBadge();
              updateDayAverageDeltaBadge(selected, daily);
              productChangeContext = { date: effectiveDate, items, options, isDemo };
              loadProductChanges(productChangeContext);
              if (selected) {
                const hourlyIso = selectedIso || sanitizeIso(effectiveDate);
                const hourlyFallback = hourlyIso && data?.hourlyByDay ? data.hourlyByDay[hourlyIso] : null;
                syncHourlyPayload({
                  iso: hourlyIso,
                  revenue: selected.revenue,
                  hourlySeries: selected.hourly || hourlyFallback,
                  hourlyByDay: data?.hourlyByDay,
                  comparison: false,
                });
              } else if (data?.hourlyByDay) {
                ingestHourlySeries(data.hourlyByDay);
              }
              renderHourlyInsights({ date: effectiveDate, isDemo });
            })
            .catch((error) => {
              console.error('Kunne ikke hente dagsomsetning:', error);
              const isTimeout = error?.status === 408 || /408/.test(String(error?.message || ''));
              const allowDemo = !attemptedDemo && error?.status === 400 &&
                (error?.body?.error === 'CONFIG_MISSING' || error?.body?.error === 'RECEIPTS_FAIL');
              if (allowDemo) {
                attemptedDemo = true;
                renderDayStatus('Bytter til demo-data ');
                renderProductInsights(null, { date, state: 'loading' });
                renderRevenueAnalysisState('loading', { date });
                renderProductChangesState('loading', { date });
                attempt({ demo: true });
                return;
              }
              if (attemptedDemo && options.demo && error?.body?.dayTotal) {
                const dayPayload = mergePreviewDayTotals(error.body.dayTotal, date, { enabled: true });
                renderDayTotals(dayPayload, { isDemo: true });
                const items = Array.isArray(error?.body?.items) ? error.body.items : Array.isArray(error?.body?.top) ? error.body.top : [];
                renderProductInsights(items, { date, isDemo: true });
                const demoFallback = Array.isArray(error?.body?.daily) ? error.body.daily : [];
                revenueAnalysisContext = { date, fallbackDaily: demoFallback, entry: dayPayload };
                renderRevenueAnalysis(revenueAnalysisContext);
                updateDayWeekDeltaBadge();
                updateDayAverageDeltaBadge(dayPayload, demoFallback);
                productChangeContext = { date, items, options, isDemo: true };
                loadProductChanges(productChangeContext);
                syncHourlyPayload({
                  iso: sanitizeIso(dayPayload?.date) || sanitizeIso(date),
                  revenue: dayPayload?.revenue,
                  hourlySeries: error.body.dayTotal?.hourly,
                  hourlyByDay: error?.body?.hourlyByDay,
                  comparison: false,
                });
                renderHourlyInsights({ date, isDemo: true });
                return;
              }
              const fallbackMessage = isTimeout
                ? 'Lightspeed brukte for lang tid. Viser siste kjente tall.'
                : (error?.body?.message || error?.message || 'Feil ved henting av omsetning');
              if (lastDayTotals && sanitizeIso(lastDayTotals.date) === sanitizeIso(date)) {
                renderDayTotals(lastDayTotals, { isDemo: lastDayTotals.isDemo, suppressStatus: true, cache: false });
                renderDayStatus(fallbackMessage, isTimeout ? 'warning' : 'error');
                updateDayWeekDeltaBadge();
                updateDayAverageDeltaBadge(lastDayTotals, revenueAnalysisContext.fallbackDaily || []);
                if (Number.isFinite(lastDayTotals.receipts)) {
                  if (dayReceiptsValueEl) dayReceiptsValueEl.textContent = qtyFmt.format(lastDayTotals.receipts);
                  if (dayReceiptsStatusEl) {
                    dayReceiptsStatusEl.textContent = lastDayTotals.receipts > 0 ? '' : fallbackMessage;
                    dayReceiptsStatusEl.dataset.tone = lastDayTotals.receipts > 0 ? (isTimeout ? 'warning' : 'muted') : (isTimeout ? 'warning' : 'error');
                  }
                  if (dayAverageStatusEl) {
                    dayAverageStatusEl.textContent = lastDayTotals.receipts > 0 ? '' : fallbackMessage;
                    dayAverageStatusEl.dataset.tone = lastDayTotals.receipts > 0 ? (isTimeout ? 'warning' : 'muted') : (isTimeout ? 'warning' : 'error');
                  }
                }
              } else {
                renderDayStatus(fallbackMessage, isTimeout ? 'warning' : 'error');
                if (dayReceiptsValueEl) dayReceiptsValueEl.textContent = '';
                if (dayReceiptsStatusEl) {
                  dayReceiptsStatusEl.textContent = fallbackMessage;
                  dayReceiptsStatusEl.dataset.tone = isTimeout ? 'warning' : 'error';
                }
                if (dayAverageStatusEl) {
                  dayAverageStatusEl.textContent = fallbackMessage;
                  dayAverageStatusEl.dataset.tone = isTimeout ? 'warning' : 'error';
                }
                updateDayAverageDeltaBadge(null);
              }
              renderProductInsights(null, {
                date,
                state: 'error',
                message: fallbackMessage,
              });
              renderRevenueAnalysisState('error', { date, message: fallbackMessage });
              renderProductChangesState('error', { date, message: fallbackMessage });
              renderHourlyInsights({ date, isDemo: lastDayTotals?.isDemo });
            });
        };

        if (PREVIEW_TODAY && sanitizeIso(date) === PREVIEW_TODAY && !attemptedDemo) {
          attemptedDemo = true;
          attempt({ demo: true });
          return;
        }

        attempt();
      };

      if (barChart) {
        barChart.addEventListener('mouseleave', hideGlobalTooltip);
      }

        if (dayPicker) {
          loadDayTotals(activeDateISO);
          dayPicker.addEventListener('change', () => {
            activeDateISO = updateSelectedDateUI(dayPicker.value || todayISO, 'day');
            loadDayTotals(activeDateISO);
            if (typeof handleActiveDateChange === 'function') {
              handleActiveDateChange(activeDateISO);
            }
          });
        } else {
          loadDayTotals(activeDateISO);
        }

        if (dayTodayBtn) {
          dayTodayBtn.addEventListener('click', () => {
            activeDateISO = updateSelectedDateUI(todayISO);
            loadDayTotals(activeDateISO);
            if (typeof handleActiveDateChange === 'function') {
              handleActiveDateChange(activeDateISO);
            }
          });
        }

      if (dayPickerTrigger && dayPicker) {
        const openNativePicker = () => {
          if (typeof dayPicker.showPicker === 'function') {
            dayPicker.showPicker();
          } else {
            dayPicker.focus();
            dayPicker.click();
          }
        };
        dayPickerTrigger.addEventListener('click', () => {
          openNativePicker();
        });
      }

        if (aiProductsPicker) {
          if (!aiProductsPicker.value) {
            aiProductsPicker.value = activeDateISO;
          }
          aiProductsPicker.addEventListener('change', () => {
            activeDateISO = updateSelectedDateUI(aiProductsPicker.value || todayISO, 'ai');
            loadDayTotals(activeDateISO);
            if (typeof handleActiveDateChange === 'function') {
              handleActiveDateChange(activeDateISO);
            }
          });
        }

        if (aiTodayBtn) {
          aiTodayBtn.addEventListener('click', () => {
            activeDateISO = updateSelectedDateUI(todayISO);
            loadDayTotals(activeDateISO);
            if (typeof handleActiveDateChange === 'function') {
              handleActiveDateChange(activeDateISO);
            }
          });
        }

      if (typeof fetch === 'function') {
        const renderChart = (days, { isDemo = false, message = '', direction = '' } = {}) => {
          updateWeekSummary(days);
          if (!barChart) return;
          barChart.innerHTML = '';
          if (chartTooltip) {
            chartTooltip.hidden = true;
            chartTooltip.dataset.visible = '0';
          }
          if (!Array.isArray(days) || !days.length) {
            barChart.dataset.empty = '1';
            barChart.removeAttribute('data-demo');
            barChart.innerHTML = `<div class="bar-chart__empty">${message || 'Ingen data for valgt dato.'}</div>`;
            return;
          }

          const revenues = days.map(d => Math.max(0, Number(d.revenue || 0)));
          const maxRevenueRaw = Math.max(...revenues);
          const positiveRevenues = revenues.filter(value => value > 0);
          const maxPositive = positiveRevenues.length ? Math.max(...positiveRevenues) : null;
          const minPositive = positiveRevenues.length > 1 ? Math.min(...positiveRevenues) : null;
          const highlightBest = Number.isFinite(maxPositive);
          const highlightWorst = Number.isFinite(minPositive) && minPositive !== maxPositive;
          const maxRevenue = maxRevenueRaw > 0 ? maxRevenueRaw : 1;
          const chartHeight = barChart.clientHeight || 240;
          const maxBarHeight = chartHeight * 0.8;
          const minBarHeight = Math.max(6, chartHeight * 0.05);

          barChart.removeAttribute('data-empty');
          if (isDemo) {
            barChart.dataset.demo = '1';
          } else {
            barChart.removeAttribute('data-demo');
          }

          const showTooltip = (barEl, friendly, revenue) => {
            if (!chartTooltip) return;
            clearTimeout(chartTooltip._hideTimer);
            const containerRect = chartCard?.getBoundingClientRect() || barChart.getBoundingClientRect();
            const barRect = barEl.getBoundingClientRect();
            const leftRaw = barRect.left + barRect.width / 2 - containerRect.left;
            const topRaw = barRect.top - containerRect.top;
            const maxLeft = containerRect.width - 16;
            const clampedLeft = Math.min(Math.max(leftRaw, 16), maxLeft);
            const clampedTop = Math.max(24, topRaw);
            chartTooltip.innerHTML = `<strong>${friendly}</strong><br><span>${moneyFmt.format(revenue)}</span>`;
            chartTooltip.style.left = `${clampedLeft}px`;
            chartTooltip.style.top = `${clampedTop}px`;
            chartTooltip.hidden = false;
            chartTooltip.dataset.visible = '1';
          };

          const hideTooltip = () => {
            if (!chartTooltip) return;
            chartTooltip.dataset.visible = '0';
            clearTimeout(chartTooltip._hideTimer);
            chartTooltip._hideTimer = setTimeout(() => {
              chartTooltip.hidden = true;
            }, 160);
          };

          days.forEach((day, index) => {
            const revenue = Math.max(0, Number(day.revenue || 0));
            const ratio = maxRevenue > 0 ? Math.max(0, Math.min(1, revenue / maxRevenue)) : 0;
            const column = document.createElement('div');
            column.className = 'bar__column';
            const columnHeight = Math.max(minBarHeight, ratio * maxBarHeight);
            const fillHeight = revenue > 0
              ? Math.max(20, Math.min(maxBarHeight, columnHeight))
              : 12;
            column.style.setProperty('--fill-height', `${fillHeight}px`);
            column.style.setProperty('--track-height', `${chartHeight}px`);
            column.dataset.zero = revenue > 0 ? '0' : '1';
            if (highlightBest && revenue === maxPositive) {
              column.dataset.tone = 'best';
            } else if (highlightWorst && revenue === minPositive) {
              column.dataset.tone = 'worst';
            }
            const bar = document.createElement('div');
            bar.className = 'bar';
            const dateObj = day.date ? new Date(`${day.date}T00:00:00`) : null;
            const dayNameRaw = dateObj && !Number.isNaN(dateObj.getTime()) ? weekdayFmt.format(dateObj) : '';
            const dayName = dayNameRaw ? dayNameRaw.replace('.', '').slice(0,3).toUpperCase() : '';
            const dateLabel = dateObj && !Number.isNaN(dateObj.getTime()) ? chartDateFmt.format(dateObj) : (day.date || '');
            const friendly = dateObj && !Number.isNaN(dateObj.getTime()) ? dateFmtLong.format(dateObj) : (day.date || '');
            const label = document.createElement('span');
            label.className = 'bar__label';
            label.innerHTML = `<strong>${dayName}</strong><small>${dateLabel}</small>`;
            bar.append(column, label);
            bar.style.setProperty('--bar-index', index);
            const eventTarget = column;
            const handleEnter = () => showTooltip(bar, friendly, revenue);
            const handleLeave = () => hideTooltip();
            eventTarget.addEventListener('mouseenter', handleEnter);
            eventTarget.addEventListener('mouseleave', handleLeave);
            eventTarget.addEventListener('focus', handleEnter);
            eventTarget.addEventListener('blur', handleLeave);
            eventTarget.tabIndex = 0;
            eventTarget.setAttribute('aria-label', `${friendly}: ${moneyFmt.format(revenue)}`);
            barChart.appendChild(bar);
          });
          triggerChartTransition(direction);
        };

        const FAST_SPAN_DAYS = 63;
        const HISTORY_PREFETCH_BUFFER_DAYS = 21;
        let historyPrefetchPromise = null;

        const updateWeekSummary = (range = []) => {
          if (!chartWeekLabel && !chartWeekTotal && !chartWeekAverage) return;
          if (!Array.isArray(range) || !range.length) {
            if (chartWeekLabel) chartWeekLabel.textContent = 'Uke ';
            if (chartWeekTotal) chartWeekTotal.textContent = 'Totalt: ';
            if (chartWeekAverage) chartWeekAverage.textContent = 'Snitt: ';
            return;
          }
          const last = range[range.length - 1];
          const first = range[0];
          const weekInfo = getISOWeekInfo(last?.date || first?.date);
          const weekNumber = weekInfo ? String(weekInfo.week).padStart(2, '0') : null;
          if (chartWeekLabel) {
            chartWeekLabel.textContent = weekNumber ? `Uke ${weekNumber}` : 'Uke ';
          }
          const totalRevenue = range.reduce((sum, entry) => {
            const value = Number(entry?.revenue || 0);
            return sum + (Number.isFinite(value) ? Math.max(0, value) : 0);
          }, 0);
          if (chartWeekTotal) {
            chartWeekTotal.textContent = `Totalt: ${moneyFmt.format(totalRevenue)}`;
          }
          if (chartWeekAverage) {
            const average = range.length ? totalRevenue / range.length : 0;
            chartWeekAverage.textContent = `Snitt: ${moneyFmt.format(average)}`;
          }
        };

        const triggerChartTransition = (direction) => {
          if (!barChart || !direction) return;
          const className = direction === 'next'
            ? 'bar-chart--slide-next'
            : direction === 'prev'
              ? 'bar-chart--slide-prev'
              : '';
          if (!className) return;
          barChart.classList.remove('bar-chart--slide-next', 'bar-chart--slide-prev');
          void barChart.offsetWidth;
          barChart.classList.add(className);
          clearTimeout(barChart._slideTimer);
          barChart._slideTimer = setTimeout(() => {
            barChart.classList.remove(className);
            barChart._slideTimer = null;
          }, 360);
        };

        const mergeDailyPayload = (payload, { replace = false } = {}) => {
          const days = Array.isArray(payload?.daily) ? payload.daily : [];
          const workingMap = replace ? new Map() : new Map(chartDataMap);
          days.forEach((entry) => {
            if (!entry?.date) return;
            workingMap.set(entry.date, entry);
          });
          const sortedDesc = Array.from(workingMap.values())
            .sort((a, b) => b.date.localeCompare(a.date));
          chartDataAll = sortedDesc;
          chartDataMap = new Map(sortedDesc.map((entry) => [entry.date, entry]));
          chartLatestDate = sortedDesc.length ? sortedDesc[0].date : todayISO;
          chartOldestDate = sortedDesc.length ? sortedDesc[sortedDesc.length - 1].date : chartLatestDate;
          return {
            sortedDesc,
            isDemo: payload?.mode === 'demo',
          };
        };

        const loadHistoricalData = async (minIso, { demo = chartIsDemo } = {}) => {
          if (!minIso || !chartDataAll.length) return { isDemo: false };
          let normalizedMin = minIso;
          if (normalizedMin.localeCompare(from) < 0) normalizedMin = from;
          const currentOldest = chartOldestDate;
          if (!currentOldest || currentOldest.localeCompare(normalizedMin) <= 0) {
            return { isDemo: false };
          }
          const buffered = addDaysISO(normalizedMin, -HISTORY_PREFETCH_BUFFER_DAYS);
          if (buffered && buffered.localeCompare(from) > 0) {
            normalizedMin = buffered;
          } else {
            normalizedMin = from;
          }
          const chunkEnd = addDaysISO(currentOldest, -1);
          if (!chunkEnd || chunkEnd.localeCompare(normalizedMin) < 0) {
            return { isDemo: false };
          }
          const payload = await fetchDaily({ demo, fromISO: normalizedMin, toISO: chunkEnd });
          const { isDemo } = mergeDailyPayload(payload, { replace: false });
          return { isDemo };
        };

      const chartWindowDays = 7;

        const startOfWeekISO = (iso) => {
          const base = parseIsoDate(iso) || parseIsoDate(todayISO);
          if (!base) return todayISO;
          const day = base.getDay();
          const offset = day === 0 ? -6 : (1 - day);
          const monday = new Date(base);
          monday.setDate(base.getDate() + offset);
          return toISODate(monday);
        };

        const endOfWeekISO = (iso) => {
          const monday = parseIsoDate(startOfWeekISO(iso));
          if (!monday) return todayISO;
          const sunday = new Date(monday);
          sunday.setDate(monday.getDate() + (chartWindowDays - 1));
          return toISODate(sunday);
        };

        const addDaysISO = (iso, delta) => {
          const base = iso ? new Date(`${iso}T00:00:00`) : new Date(`${todayISO}T00:00:00`);
          if (Number.isNaN(base.getTime())) return toISODate(new Date(`${todayISO}T00:00:00`));
          base.setDate(base.getDate() + delta);
          return toISODate(base);
        };

        const clampCursorDate = (iso) => {
          const latestActual = chartDataAll.length ? chartDataAll[0].date : todayISO;
          const oldestActual = chartDataAll.length ? chartDataAll[chartDataAll.length - 1].date : latestActual;
          const latestEnd = endOfWeekISO(latestActual);
          const earliestCandidate = chartDataAll.length >= chartWindowDays
            ? addDaysISO(oldestActual, chartWindowDays - 1)
            : latestActual;
          const earliestEnd = endOfWeekISO(earliestCandidate);
          let target = iso || latestEnd;
          if (target.localeCompare(latestEnd) > 0) target = latestEnd;
          if (target.localeCompare(earliestEnd) < 0) target = earliestEnd;
          return endOfWeekISO(target);
        };

        const buildChartRange = (endIso) => {
          const cursor = clampCursorDate(endIso);
          const endDate = parseIsoDate(cursor) || parseIsoDate(todayISO);
          const startDate = (() => {
            const monday = parseIsoDate(startOfWeekISO(cursor));
            if (monday) return monday;
            if (!endDate) return null;
            const fallback = new Date(endDate);
            fallback.setDate(endDate.getDate() - (chartWindowDays - 1));
            return fallback;
          })();
          const range = [];
          if (!endDate || !startDate) return { cursor, range };
          for (let i = 0; i < chartWindowDays; i++) {
            const current = new Date(startDate);
            current.setDate(startDate.getDate() + i);
            const iso = toISODate(current);
            const entry = chartDataMap.get(iso) || { date: iso, revenue: 0, guests: 0, receipts: 0 };
            range.push(entry);
          }
          return { cursor, range };
        };

        const updateChartNavButtons = () => {
          if (!chartPrevBtn || !chartNextBtn) return;
          if (chartNavBusy) {
            chartPrevBtn.disabled = true;
            chartNextBtn.disabled = true;
            return;
          }
          if (!chartDataAll.length) {
            chartPrevBtn.disabled = true;
            chartNextBtn.disabled = true;
            return;
          }
          const latestActual = chartDataAll[0]?.date || todayISO;
          const oldestActual = chartDataAll[chartDataAll.length - 1]?.date || latestActual;
          const latestEnd = endOfWeekISO(latestActual);
          const earliestCandidate = chartDataAll.length >= chartWindowDays
            ? addDaysISO(oldestActual, chartWindowDays - 1)
            : latestActual;
          const earliestEnd = endOfWeekISO(earliestCandidate);
          const cursorEnd = chartCursorDate || latestEnd;
          chartPrevBtn.disabled = cursorEnd.localeCompare(earliestEnd) <= 0;
          chartNextBtn.disabled = cursorEnd.localeCompare(latestEnd) >= 0;
        };

        const renderChartWindow = (endIso, { isDemo = false, direction = '' } = {}) => {
          const { cursor, range } = buildChartRange(endIso);
          chartCursorDate = cursor;
          renderChart(range, { isDemo, direction });
          updateChartNavButtons();
        };

        const shiftChartWindow = (offsetDays) => {
          if (!chartCursorDate || chartNavBusy) return;
          chartNavBusy = true;
          if (chartPrevBtn) chartPrevBtn.disabled = true;
          if (chartNextBtn) chartNextBtn.disabled = true;
          hideGlobalTooltip();
          const targetRaw = addDaysISO(chartCursorDate, offsetDays);
          const direction = offsetDays > 0 ? 'next' : offsetDays < 0 ? 'prev' : '';
          const perform = async () => {
            let fetchDemo = chartIsDemo;
            if (direction === 'prev') {
              const weekStart = startOfWeekISO(targetRaw);
              if (weekStart) {
                if (historyPrefetchPromise) {
                  try { await historyPrefetchPromise; } catch (_) { /* ignore */ }
                }
                const { isDemo: historyDemo } = await loadHistoricalData(weekStart, { demo: chartIsDemo });
                if (historyDemo) fetchDemo = true;
              }
            }
            chartIsDemo = chartIsDemo || fetchDemo;
            renderChartWindow(targetRaw, { isDemo: chartIsDemo, direction });
          };
          perform()
            .catch((error) => {
              console.error('Kunne ikke bla i omsetningsdiagram:', error);
            })
            .finally(() => {
              chartNavBusy = false;
              updateChartNavButtons();
            });
        };

        const fromDate = (() => {
          const current = new Date(today);
          const mayFirst = new Date(current.getFullYear(), 4, 1);
          if (current < mayFirst) {
            mayFirst.setFullYear(mayFirst.getFullYear() - 1);
          }
          return mayFirst;
        })();
        const from = toISODate(fromDate);

        const fetchDailyRange = async ({ fromISO, toISO, demo = false } = {}) => {
          const url = new URL('/.netlify/functions/lightspeed', apiBase);
          url.searchParams.set('from', fromISO);
          url.searchParams.set('to', toISO);
          url.searchParams.set('group', 'daily');
          url.searchParams.set('cache', '1');
          const fromDateParsed = parseIsoDate(fromISO);
          const toDateParsed = parseIsoDate(toISO);
          const spanDays = (fromDateParsed && toDateParsed)
            ? Math.max(1, Math.round((toDateParsed - fromDateParsed) / 86400000) + 1)
            : 60;
          const windowSize = Math.min(90, Math.max(spanDays, 21));
          url.searchParams.set('limit', String(windowSize));
          url.searchParams.set('window', String(windowSize));
          if (demo) url.searchParams.set('demo', '1');

          const response = await fetch(url.toString(), { headers: { accept: 'application/json' } });
          const payload = await response.json().catch(() => null);
          if (!response.ok) {
            const error = new Error(`HTTP ${response.status}`);
            error.status = response.status;
            error.body = payload;
            throw error;
          }
          return payload;
        };

        const fetchDailyWithSplit = async ({ fromISO, toISO, demo = false, depth = 0 } = {}) => {
          try {
            const payload = await fetchDailyRange({ fromISO, toISO, demo });
            return [payload];
          } catch (error) {
            if (error?.status === 504 && depth < 4) {
              const fromDateObj = parseIsoDate(fromISO);
              const toDateObj = parseIsoDate(toISO);
              if (fromDateObj && toDateObj && fromDateObj < toDateObj) {
                const spanDays = Math.max(2, Math.round((toDateObj - fromDateObj) / 86400000) + 1);
                const splitDays = Math.floor(spanDays / 2);
                const midDate = new Date(fromDateObj);
                midDate.setDate(midDate.getDate() + splitDays - 1);
                if (midDate >= toDateObj) {
                  midDate.setDate(toDateObj.getDate() - 1);
                }
                if (midDate < fromDateObj) {
                  throw error;
                }
                const midISO = toISODate(midDate);
                const nextStart = new Date(midDate);
                nextStart.setDate(nextStart.getDate() + 1);
                if (nextStart > toDateObj) {
                  throw error;
                }
                const nextISO = toISODate(nextStart);
                const firstHalf = await fetchDailyWithSplit({ fromISO, toISO: midISO, demo, depth: depth + 1 });
                const secondHalf = await fetchDailyWithSplit({ fromISO: nextISO, toISO, demo, depth: depth + 1 });
                return [...firstHalf, ...secondHalf];
              }
            }
            throw error;
          }
        };

        const fetchDaily = async ({ demo = false, fromISO = from, toISO = todayISO } = {}) => {
          const baseRange = { fromISO, toISO, demo };
          try {
            return await fetchDailyRange(baseRange);
          } catch (error) {
            if (!(error?.status === 504)) {
              throw error;
            }
          }

          const startDate = parseIsoDate(fromISO);
          const endDate = parseIsoDate(toISO);
          if (!startDate || !endDate) {
            return fetchDailyRange(baseRange);
          }

          const ranges = [];
          const chunkSize = 60;
          let cursorStart = new Date(startDate);
          while (cursorStart <= endDate) {
            const chunkStart = new Date(cursorStart);
            const chunkEnd = new Date(cursorStart);
            chunkEnd.setDate(chunkEnd.getDate() + (chunkSize - 1));
            if (chunkEnd > endDate) chunkEnd.setTime(endDate.getTime());
            ranges.push({
              fromISO: toISODate(chunkStart),
              toISO: toISODate(chunkEnd),
            });
            chunkEnd.setDate(chunkEnd.getDate() + 1);
            cursorStart = new Date(chunkEnd);
          }

          const results = await Promise.all(
            ranges.map((range) => fetchDailyWithSplit({ ...range, demo }))
          );
          const payloads = results.flat();

          const combinedMap = new Map();
          let representativePayload = null;

          payloads.forEach((payload) => {
            if (!payload) return;
            if (!representativePayload) {
              representativePayload = { ...payload };
            } else if (payload && typeof payload === 'object') {
              if (payload.mode) representativePayload.mode = payload.mode;
              if (payload.statusMessage && !representativePayload.statusMessage) {
                representativePayload.statusMessage = payload.statusMessage;
              }
            }
            if (Array.isArray(payload?.daily)) {
              payload.daily.forEach((entry) => {
                if (!entry?.date) return;
                combinedMap.set(entry.date, entry);
              });
            }
          });

          const daily = Array.from(combinedMap.values())
            .sort((a, b) => a.date.localeCompare(b.date));

          if (!representativePayload) {
            return { daily };
          }
          representativePayload.daily = daily;
          return representativePayload;
        };

        let attemptedDemoFallback = false;
        renderChart([], { message: 'Henter ' });
        updateChartNavButtons();

        const load = (options = {}) => {
          const demo = !!options.demo;
          const initialCandidate = addDaysISO(todayISO, -(FAST_SPAN_DAYS - 1));
          const initialFromISO = initialCandidate && initialCandidate.localeCompare(from) > 0 ? initialCandidate : from;
          const needsHistoryPrefetch = initialFromISO.localeCompare(from) > 0;

          fetchDaily({ demo, fromISO: initialFromISO, toISO: todayISO })
            .then((payload) => {
              const { isDemo } = mergeDailyPayload(payload, { replace: true });
              chartIsDemo = demo || isDemo;
              renderChartWindow(chartLatestDate, { isDemo: chartIsDemo });
              if (revenueAnalysisContext?.date) {
                renderRevenueAnalysis(revenueAnalysisContext);
              }
              updateChartNavButtons();

              if (needsHistoryPrefetch && !historyPrefetchPromise) {
                const scheduleHistoryFetch = async () => {
                  const { isDemo: historyDemo } = await loadHistoricalData(from, { demo });
                  if (historyDemo) chartIsDemo = true;
                  updateChartNavButtons();
                };
                historyPrefetchPromise = scheduleHistoryFetch()
                  .catch((historyError) => {
                    console.error('Kunne ikke hente historiske data:', historyError);
                  })
                  .finally(() => {
                    historyPrefetchPromise = null;
                  });
              }
            })
            .catch((error) => {
              console.error('Kunne ikke hente daglig omsetning:', error);
              const isTimeout = error?.status === 408 || /408/.test(String(error?.message || ''));
              const shouldTryDemo = !attemptedDemoFallback && (
                error?.status === 400 &&
                (error?.body?.error === 'CONFIG_MISSING' || error?.body?.error === 'RECEIPTS_FAIL')
              );
              if (shouldTryDemo) {
                attemptedDemoFallback = true;
                renderChart([], { message: 'Bytter til demo-data ' });
                load({ demo: true });
                return;
              }
              if (attemptedDemoFallback && options.demo) {
                try {
                  mergeDailyPayload(
                    { daily: Array.isArray(error?.body?.daily) ? error.body.daily : [] },
                    { replace: true }
                  );
                  chartIsDemo = true;
                  renderChartWindow(chartLatestDate, { isDemo: true });
                  updateChartNavButtons();
                  return;
                } catch (_) {
                  /* fall through */
                }
              }
              if (chartDataAll.length) {
                const fallbackCursor = chartCursorDate || chartLatestDate;
                renderChartWindow(fallbackCursor, { isDemo: chartIsDemo, direction: '' });
              } else {
                chartDataAll = [];
                chartDataMap = new Map();
                chartCursorDate = null;
                chartLatestDate = todayISO;
                chartOldestDate = todayISO;
                chartIsDemo = false;
                const chartMessage = isTimeout
                  ? 'Lightspeed brukte for lang tid. Prv igjen om litt.'
                  : (error?.body?.message || error?.message || 'Feil ved henting');
                renderChart([], { message: chartMessage });
              }
              updateChartNavButtons();
            });
        };

        if (chartPrevBtn) {
          chartPrevBtn.addEventListener('click', () => shiftChartWindow(-chartWindowDays));
        }
        if (chartNextBtn) {
          chartNextBtn.addEventListener('click', () => shiftChartWindow(chartWindowDays));
        }

        load();
      }

      const tripletexSection = document.querySelector('[data-tripletex-config]');
      if (tripletexSection) {
        const resolveTripletexEndpoint = async () => {
          if (resolveTripletexEndpoint.cache) return resolveTripletexEndpoint.cache;
          const candidates = [
            '/.netlify/functions/tripletex',
            '/api/tripletex',
            '/functions/tripletex'
          ];
          for (const base of candidates) {
            try {
              const ping = await fetch(`${base}?ping=1`, { method: 'GET' });
              if (ping.ok) {
                resolveTripletexEndpoint.cache = base;
                return base;
              }
            } catch (_) {
              /* ignore */
            }
          }
          resolveTripletexEndpoint.cache = candidates[0];
          return resolveTripletexEndpoint.cache;
        };

        const sectionConfigRaw = tripletexSection.dataset.tripletexConfig || '{}';
        let sectionConfig = {};
        try { sectionConfig = JSON.parse(sectionConfigRaw); } catch (_) {
          console.warn('Tripletex-config: kunne ikke tolke JSON');
        }

        const sourceProducts = Object.entries(sectionConfig).map(([key, value]) => ({
          key,
          label: value?.label || key,
          revenueAccount: value?.accounts?.revenue || null,
          costAccount: value?.accounts?.cost || null,
        })).filter((item) => item.revenueAccount || item.costAccount);

        if (!sourceProducts.length) {
          sourceProducts.push({ key: 'beer', label: 'l', revenueAccount: 'id-289896744', costAccount: 'id-289896742' });
          sourceProducts.push({ key: 'wine', label: 'Vin', revenueAccount: 'id-289896745', costAccount: 'id-289896743' });
        }

        // Include explicit account-number mapping for konto 3003 (id 289896744) so postings are fetched correctly
        sourceProducts.push({ key: 'sales3003', label: 'Salg 3003', revenueAccount: '3003' });
        // Aggregert salg for alle kontoer 3000-3999
        sourceProducts.push({ key: 'sales3xx', label: 'Salg 3000-3999', accountRange: { min: 3000, max: 3999 } });

        const aggregateProduct = { key: 'sales', label: 'Salg', sources: sourceProducts.map((p) => p.key) };
        const products = [aggregateProduct];

        const accountsParam = [];
        sourceProducts.forEach((product) => {
          if (product.revenueAccount) accountsParam.push(`${product.key}Revenue|${product.label} salg:${product.revenueAccount}`);
          if (product.costAccount) accountsParam.push(`${product.key}Cost|${product.label} varekost:${product.costAccount}`);
          if (product.accountRange) {
            const min = Number(product.accountRange.min) || 0;
            const max = Number(product.accountRange.max) || '';
            accountsParam.push(`${product.key}Range|${product.label}:range-${min}-${max}`);
          }
        });

        const makeIsoDate = (yearVal, monthVal, dayVal) => `${String(yearVal).padStart(4, '0')}-${String(monthVal).padStart(2, '0')}-${String(dayVal).padStart(2, '0')}`;
        const buildTripletexContext = (baseIso = activeDateISO, rangeType = 'month') => {
          const anchorIso = sanitizeIso(baseIso) || todayISO;
          const anchorDate = parseIsoDate(anchorIso) || new Date();
          const effectiveRange = rangeType || 'month';
          const monthForReport = effectiveRange === 'month'
            ? new Date(Date.UTC(anchorDate.getFullYear(), anchorDate.getMonth() - 1, 1))
            : new Date(Date.UTC(anchorDate.getFullYear(), anchorDate.getMonth(), 1));
          const year = monthForReport.getUTCFullYear();
          const month = monthForReport.getUTCMonth() + 1;
          const monthKey = `${year}-${String(month).padStart(2, '0')}`;
          const endOfMonth = new Date(Date.UTC(monthForReport.getUTCFullYear(), monthForReport.getUTCMonth() + 1, 0));
          return {
            anchorIso,
            year,
            monthKey,
            from: effectiveRange === 'month'
              ? makeIsoDate(monthForReport.getUTCFullYear(), monthForReport.getUTCMonth() + 1, 1)
              : makeIsoDate(year, 1, 1),
            to: effectiveRange === 'month'
              ? makeIsoDate(endOfMonth.getUTCFullYear(), endOfMonth.getUTCMonth() + 1, endOfMonth.getUTCDate())
              : makeIsoDate(anchorDate.getFullYear(), anchorDate.getMonth() + 1, anchorDate.getDate()),
          };
        };
        tripletexContext = buildTripletexContext();
        updateReportsRangeLabel(tripletexContext.anchorIso, 'month');
      if (reportsToolbar) {
        const reportsToolbarEl = reportsToolbar;
        const monthButtons = reportsToolbarEl ? Array.from(reportsToolbarEl.querySelectorAll('.reports-month')) : [];
        const weekGrid = reportsToolbarEl ? reportsToolbarEl.querySelector('[data-week-grid]') : null;
        const dayGrid = reportsToolbarEl ? reportsToolbarEl.querySelector('[data-day-grid]') : null;
        const dayPanelInput = reportsToolbarEl ? reportsToolbarEl.querySelector('[data-range-day-input]') : null;
        const dayPanelToday = reportsToolbarEl ? reportsToolbarEl.querySelector('[data-range-day-today]') : null;
        const dayHintEl = reportsToolbarEl ? reportsToolbarEl.querySelector('[data-range-panel="day"] .reports-hint') : null;
        const monthLabelFmt = new Intl.DateTimeFormat('nb-NO', { month: 'long', year: 'numeric' });
        const weekRangeFmt = new Intl.DateTimeFormat('nb-NO', { day: '2-digit', month: 'short' });
        const dayLabelFmt = new Intl.DateTimeFormat('nb-NO', { weekday: 'short', day: 'numeric', month: 'short', year: 'numeric' });
        const reportsState = {
          activeRange: null,
          data: { month: null, week: null, day: null },
          selection: { month: null, week: null, day: null },
          loading: { month: false, week: false, day: false },
          error: { month: null, week: null, day: null },
        };
        const resetTripletexState = () => {
          ['month', 'week', 'day'].forEach((range) => {
            reportsState.data[range] = null;
            reportsState.selection[range] = null;
            reportsState.error[range] = null;
            reportsState.loading[range] = false;
          });
          if (weekGrid) {
            weekGrid.dataset.initialized = '0';
            weekGrid.innerHTML = '';
          }
        };
        if (dayPicker && dayPicker.value) {
          const initialDay = sanitizeIso(dayPicker.value);
          if (initialDay) reportsState.selection.day = initialDay;
        }
        if (dayPanelInput && reportsState.selection.day) {
          dayPanelInput.value = reportsState.selection.day;
        }

        const ensureWeekButtons = () => {
          if (!weekGrid) return;
          if (weekGrid.dataset.initialized === '1') return;
          weekGrid.innerHTML = '';
          for (let week = 1; week <= 53; week += 1) {
            const year = tripletexContext.year || today.getFullYear();
            const weekKey = `${year}-W${String(week).padStart(2, '0')}`;
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'reports-week';
            button.textContent = `Uke ${String(week).padStart(2, '0')}`;
            button.dataset.week = String(week);
            button.dataset.weekKey = weekKey;
            button.setAttribute('aria-pressed', 'false');
            weekGrid.appendChild(button);
          }
          weekGrid.dataset.initialized = '1';
        };

        const updateProductHeader = (productKey, label) => {
          const card = tripletexSection.querySelector(`[data-tripletex-product="${productKey}"]`);
          const heading = card?.querySelector('[data-tripletex-label]');
          if (card && heading) heading.textContent = `Tripletex  ${label}`;
        };

        const formatMonthKeyLabel = (monthKey) => {
          if (!monthKey) return '';
          const [y, m] = monthKey.split('-').map((v) => Number(v));
          if (!Number.isFinite(y) || !Number.isFinite(m)) return '';
          const parsed = new Date(y, m - 1, 1);
          return monthLabelFmt.format(parsed);
        };

        products.forEach((product) => updateProductHeader(product.key, product.label));

        const getRangePanel = (range) => reportsToolbarEl ? reportsToolbarEl.querySelector(`[data-range-panel="${range}"]`) : null;
        const getRangeButton = (range) => reportsToolbarEl ? reportsToolbarEl.querySelector(`[data-range="${range}"]`) : null;

        const rangeButtonDefaults = new Map();
        if (reportsToolbarEl) {
          reportsToolbarEl.querySelectorAll('[data-range]').forEach((btn) => {
            const range = btn.dataset.range;
            if (range && !rangeButtonDefaults.has(range)) {
              rangeButtonDefaults.set(range, btn.textContent.trim());
            }
          });
        }

        const resolveMonthLabelFromKey = (periodKey) => {
          if (!periodKey) return '';
          const dataset = reportsState.data.month;
          const metaLabel = dataset?.meta?.get(periodKey)?.label;
          if (metaLabel) {
            const clean = metaLabel.split('')[0].trim();
            if (clean) return clean;
          }
          const [year, month] = String(periodKey).split('-');
          if (year && month) {
            const parsed = new Date(`${year}-${month}-01T00:00:00`);
            if (!Number.isNaN(parsed.getTime())) {
              return monthLabelFmt.format(parsed);
            }
          }
          return periodKey;
        };

        const updateMonthRangeButton = () => {
          const button = getRangeButton('month');
          if (!button) return;
          const defaultLabel = rangeButtonDefaults.get('month') || button.textContent.trim();
          const selectionKey = reportsState.selection.month || tripletexContext?.monthKey || null;
          button.textContent = defaultLabel;
          if (selectionKey) button.setAttribute('data-selected', 'true');
          else button.removeAttribute('data-selected');
        };

        const updateRangeButtonsState = () => {
          if (!reportsToolbarEl) return;
          reportsToolbarEl.querySelectorAll('[data-range]').forEach((btn) => {
            const btnRange = btn.dataset.range;
            const isActive = reportsState.activeRange === btnRange;
            btn.classList.toggle('active', isActive);
            btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
            const panel = getRangePanel(btnRange);
            const expanded = panel ? !panel.hidden : false;
            btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
          });
        };

        const setRangePanelsVisibility = (rangeToShow = null) => {
          if (!reportsToolbarEl) return;
          reportsToolbarEl.querySelectorAll('[data-range-panel]').forEach((panel) => {
            const shouldShow = Boolean(rangeToShow && panel.dataset.rangePanel === rangeToShow);
            panel.hidden = !shouldShow;
            if (shouldShow) panel.dataset.open = 'true';
            else panel.removeAttribute('data-open');
          });
          updateRangeButtonsState();
        };

        const hideRangePanel = (range) => {
          const panel = getRangePanel(range);
          if (!panel) return;
          panel.hidden = true;
          panel.removeAttribute('data-open');
          updateRangeButtonsState();
        };

        updateMonthRangeButton();

        const setStatus = (productKey, text, tone = 'muted') => {
          const card = tripletexSection.querySelector(`[data-tripletex-product="${productKey}"]`);
          const statusEl = card?.querySelector('[data-tripletex-status]');
          if (statusEl) {
            statusEl.textContent = text;
            statusEl.dataset.tone = tone;
          }
        };

        const setStatusAll = (text, tone = 'muted') => {
          products.forEach((product) => setStatus(product.key, text, tone));
        };

        const setTable = (productKey, rows) => {
          const card = tripletexSection.querySelector(`[data-tripletex-product="${productKey}"]`);
          const body = card?.querySelector('[data-tripletex-table]');
          if (!body) return;
          body.innerHTML = '';
          if (!rows.length) {
            const emptyRow = document.createElement('tr');
            const cell = document.createElement('td');
            cell.colSpan = 4;
            cell.className = 'muted';
            cell.textContent = 'Ingen transaksjoner i perioden';
            emptyRow.appendChild(cell);
            body.appendChild(emptyRow);
            return;
          }
          rows.forEach((row) => {
            const tr = document.createElement('tr');
            const periodCell = document.createElement('td');
            periodCell.textContent = row.label || row.monthLabel || row.key || '';
            if (row.hint) periodCell.title = row.hint;
            const revenueCell = document.createElement('td');
            revenueCell.className = 'numeric';
            revenueCell.textContent = row.revenue;
            const costCell = document.createElement('td');
            costCell.className = 'numeric';
            costCell.textContent = row.cost;
            const marginCell = document.createElement('td');
            marginCell.className = 'numeric';
            if (row.margin == null) {
              marginCell.classList.add('muted');
              marginCell.textContent = '';
            } else {
              if (row.margin >= 0) marginCell.classList.add('trend-positive');
              else marginCell.classList.add('trend-negative');
              marginCell.textContent = percentFmt.format(row.margin);
            }
            tr.append(periodCell, revenueCell, costCell, marginCell);
            body.appendChild(tr);
          });
        };

        const salesApiEndpoint = '/.netlify/functions/tripletex-sales';
        let salesFetchInFlight = null;
        const fetchLiveSalesAggregate = async (from, to) => {
          if (!from || !to) return;
          if (salesFetchInFlight) salesFetchInFlight.abort?.();
          setStatus('sales', 'Henter ', 'muted');
          setTable('sales', [{ key: 'loading', label: 'Laster ', revenue: '', cost: '', margin: null }]);
          const controller = new AbortController();
          salesFetchInFlight = controller;
          try {
            const url = `${salesApiEndpoint}?from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}`;
            const res = await fetch(url, { signal: controller.signal });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();
            const monthLabel = data?.monthLabel || '';
            const total = Number(data?.totalSales || 0);
            const formatted = Number.isFinite(total) ? moneyFmt.format(total) : '';
            setTable('sales', [{
              key: 'range',
              label: monthLabel || `${from}  ${to}`,
              revenue: formatted,
              cost: '',
              margin: null,
            }]);
            setStatus('sales', monthLabel || `${from}  ${to}`, 'muted');
          } catch (error) {
            if (controller.signal.aborted) return;
            setStatus('sales', 'Kunne ikke hente Tripletex-data', 'error');
            setTable('sales', [{ key: 'error', label: '', revenue: '', cost: '', margin: null }]);
          } finally {
            if (salesFetchInFlight === controller) salesFetchInFlight = null;
          }
        };

        const formatPeriodHint = (meta) => {
          const start = meta?.start ? parseIsoDate(meta.start) : null;
          const end = meta?.end ? parseIsoDate(meta.end) : null;
          if (start && end) return `${dateFmtShort.format(start)}  ${dateFmtShort.format(end)}`;
          if (start) return dateFmtShort.format(start);
          return '';
        };

        const formatPeriodLabel = (rangeType, key, meta) => {
          if (rangeType === 'month') {
            const labelDate = meta?.start ? parseIsoDate(meta.start) : null;
            if (labelDate) return monthLabelFmt.format(labelDate);
            const [yearPart, monthPart] = key.split('-');
            if (yearPart && monthPart) {
              return monthLabelFmt.format(new Date(Number(yearPart), Number(monthPart) - 1, 1));
            }
          } else if (rangeType === 'week') {
            const weekNumber = meta?.week || Number(String(key).split('-W')[1] || 0);
            const start = meta?.start ? parseIsoDate(meta.start) : null;
            const end = meta?.end ? parseIsoDate(meta.end) : null;
            if (start && end) {
              return `Uke ${String(weekNumber).padStart(2, '0')}  ${weekRangeFmt.format(start)}  ${weekRangeFmt.format(end)}`;
            }
            if (weekNumber) return `Uke ${String(weekNumber).padStart(2, '0')}`;
          } else if (rangeType === 'day') {
            const dateValue = meta?.date ? parseIsoDate(meta.date) : meta?.start ? parseIsoDate(meta.start) : parseIsoDate(key);
            if (dateValue) return dayLabelFmt.format(dateValue);
          }
          return key;
        };

        const normalizeTripletexResponse = (payload, { rangeType, from, to, year }) => {
          const aggregates = Array.isArray(payload?.accounts) ? payload.accounts : [];
          const aggregateMap = new Map(aggregates.map((entry) => [entry.key, entry]));
          const dataset = {
            rangeType,
            products: {},
            availableKeys: new Set(),
            meta: new Map(),
            keyByMonth: new Map(),
            summary: { start: from || null, end: to || null, label: '' },
          };

          const updateSummary = (value) => {
            if (!value) return;
            if (!dataset.summary.start || value < dataset.summary.start) dataset.summary.start = value;
            if (!dataset.summary.end || value > dataset.summary.end) dataset.summary.end = value;
          };

        const ensureMeta = (key, bucket) => {
          if (!key || key === 'ukjent') return null;
          if (!dataset.meta.has(key)) {
              const start = bucket?.meta?.start || bucket?.firstDate || null;
              const end = bucket?.meta?.end || bucket?.lastDate || null;
              const meta = {
                key,
                start,
                end,
                week: bucket?.meta?.week || null,
                year: bucket?.meta?.year || null,
                date: bucket?.meta?.date || null,
              };
              dataset.meta.set(key, meta);
            } else {
              const meta = dataset.meta.get(key);
              const start = bucket?.meta?.start || bucket?.firstDate || null;
              const end = bucket?.meta?.end || bucket?.lastDate || null;
              if (start && (!meta.start || start < meta.start)) meta.start = start;
              if (end && (!meta.end || end > meta.end)) meta.end = end;
              if (!meta.week && bucket?.meta?.week) meta.week = bucket.meta.week;
              if (!meta.year && bucket?.meta?.year) meta.year = bucket.meta.year;
              if (!meta.date && bucket?.meta?.date) meta.date = bucket.meta.date;
            }
            return dataset.meta.get(key);
          };

          sourceProducts.forEach((product) => {
            const revenueEntry = product.revenueAccount ? aggregateMap.get(`${product.key}Revenue`) : null;
            const costEntry = product.costAccount ? aggregateMap.get(`${product.key}Cost`) : null;
            const revenueBuckets = revenueEntry?.periods || revenueEntry?.months || {};
            const costBuckets = costEntry?.periods || costEntry?.months || {};
            const periodKeys = new Set([
              ...Object.keys(revenueBuckets || {}),
              ...Object.keys(costBuckets || {}),
            ]);
            const rows = [];
            periodKeys.forEach((periodKey) => {
              if (!periodKey || periodKey === 'ukjent') return;
              const revenueBucket = revenueBuckets?.[periodKey];
              const costBucket = costBuckets?.[periodKey];
              const meta = ensureMeta(periodKey, revenueBucket || costBucket || {});
              if (meta) {
                meta.label = meta.label || formatPeriodLabel(rangeType, periodKey, meta);
                meta.hint = meta.hint || formatPeriodHint(meta);
                updateSummary(meta.start);
                updateSummary(meta.end);
                if (rangeType === 'month') {
                  const monthPart = periodKey.slice(5, 7);
                  if (monthPart) dataset.keyByMonth.set(monthPart, periodKey);
                }
              }
              const revenueAbs = Number(revenueBucket?.totalAbsolute || 0);
              const costAbs = Number(costBucket?.totalAbsolute || 0);
              const margin = revenueAbs > 0 ? (revenueAbs - costAbs) / revenueAbs : null;
              rows.push({
                key: periodKey,
                label: meta?.label || periodKey,
                hint: meta?.hint || '',
                revenue: moneyFmt.format(revenueAbs),
                cost: moneyFmt.format(costAbs),
                revenueValue: revenueAbs,
                costValue: costAbs,
                margin,
              });
              if (revenueAbs > 0.001 || costAbs > 0.001) dataset.availableKeys.add(periodKey);
            });
            rows.sort((a, b) => a.key.localeCompare(b.key));
            dataset.products[product.key] = { label: product.label, rows };
          });

          if (aggregateProduct) {
            const aggregateRowsMap = new Map();
            const aggregateLabel = aggregateProduct.label || 'Salg';
            sourceProducts.forEach((product) => {
              const rows = dataset.products[product.key]?.rows || [];
              rows.forEach((row) => {
                const current = aggregateRowsMap.get(row.key) || {
                  key: row.key,
                  label: row.label,
                  hint: row.hint,
                  revenueValue: 0,
                  costValue: 0,
                };
                current.revenueValue += Number(row.revenueValue || 0);
                current.costValue += Number(row.costValue || 0);
                aggregateRowsMap.set(row.key, current);
              });
            });
            const aggregateRows = Array.from(aggregateRowsMap.values()).map((row) => {
              const revenueValue = Number(row.revenueValue || 0);
              const costValue = Number(row.costValue || 0);
              const margin = revenueValue > 0 ? (revenueValue - costValue) / revenueValue : null;
              return {
                key: row.key,
                label: row.label,
                hint: row.hint || '',
                revenueValue,
                costValue,
                revenue: moneyFmt.format(revenueValue),
                cost: moneyFmt.format(costValue),
                margin,
              };
            }).sort((a, b) => a.key.localeCompare(b.key));
            dataset.products[aggregateProduct.key] = { label: aggregateLabel, rows: aggregateRows };
          }

          if (rangeType === 'month') {
            for (let month = 1; month <= 12; month += 1) {
              const monthPart = String(month).padStart(2, '0');
              const key = `${year}-${monthPart}`;
              if (!dataset.meta.has(key)) {
                const start = makeIsoDate(year, month, 1);
                const endDate = new Date(Date.UTC(year, month, 0));
                const end = makeIsoDate(endDate.getUTCFullYear(), endDate.getUTCMonth() + 1, endDate.getUTCDate());
                const labelDate = parseIsoDate(start);
                dataset.meta.set(key, {
                  key,
                  start,
                  end,
                  label: labelDate ? monthLabelFmt.format(labelDate) : key,
                  hint: formatPeriodHint({ start, end }),
                });
              }
              if (!dataset.keyByMonth.has(monthPart)) {
                dataset.keyByMonth.set(monthPart, key);
              }
            }
          }

          const metaValues = Array.from(dataset.meta.values()).sort((a, b) => a.key.localeCompare(b.key));
          if (!dataset.summary.start && metaValues[0]?.start) dataset.summary.start = metaValues[0].start;
          if (!dataset.summary.end && metaValues[metaValues.length - 1]?.end) dataset.summary.end = metaValues[metaValues.length - 1].end;
          if (dataset.summary.start && dataset.summary.end) {
            const startDate = parseIsoDate(dataset.summary.start);
            const endDate = parseIsoDate(dataset.summary.end);
            if (startDate && endDate) {
              dataset.summary.label = `${dateFmtShort.format(startDate)}  ${dateFmtShort.format(endDate)}`;
            }
          }
          return dataset;
        };

        const scrollIntoViewQuietly = (element) => {
          if (!element || typeof element.scrollIntoView !== 'function') return;
          element.scrollIntoView({ block: 'nearest', inline: 'center', behavior: 'smooth' });
        };

        const getSortedRangeKeys = (rangeType, { includeMeta = false } = {}) => {
          const dataset = reportsState.data[rangeType];
          if (!dataset) return [];
          const metaKeys = Array.from(dataset.meta?.keys?.() || []);
          metaKeys.sort((a, b) => a.localeCompare(b));
          if (!includeMeta && dataset.availableKeys && dataset.availableKeys.size) {
            const filtered = metaKeys.filter((key) => dataset.availableKeys.has(key));
            if (filtered.length) return filtered;
          }
          return metaKeys;
        };

        const setRangeSelection = (rangeType, key, { syncDateUI = false } = {}) => {
          reportsState.selection[rangeType] = key || null;
          if (rangeType === 'day' && syncDateUI) {
            updateSelectedDateUI(key, 'day');
          }
          if (rangeType === 'day' && dayPanelInput) {
            dayPanelInput.value = key || '';
          }
          if (rangeType === 'month') {
            updateMonthRangeButton();
          }
        };

        const ensureSelectionValid = (rangeType) => {
          const dataset = reportsState.data[rangeType];
          if (!dataset) return false;
          const available = Array.from(dataset.availableKeys || []);
          const metaKeys = getSortedRangeKeys(rangeType, { includeMeta: true });
          const current = reportsState.selection[rangeType];
          const candidates = [];
          if (rangeType === 'month' && tripletexContext?.monthKey) candidates.push(tripletexContext.monthKey);
          if (rangeType === 'week') {
            const info = getISOWeekInfo(tripletexContext?.anchorIso || activeDateISO || todayISO);
            if (info?.key) candidates.push(info.key);
          }
          if (rangeType === 'day') {
            const anchor = sanitizeIso(tripletexContext?.anchorIso || activeDateISO || todayISO);
            if (anchor) candidates.push(anchor);
          }
          if (current) candidates.push(current);
          const pick = (pool) => candidates.find((key) => key && pool.includes(key));
          let next = pick(available);
          if (!next) next = pick(metaKeys);
          if (!next && metaKeys.length) next = metaKeys[metaKeys.length - 1];
          if (next && next !== current) {
            setRangeSelection(rangeType, next);
            return true;
          }
          return false;
        };

        const cycleRangeSelection = (rangeType, direction = 1) => {
          const keys = getSortedRangeKeys(rangeType);
          if (!keys.length) return;
          const current = reportsState.selection[rangeType];
          let index = current ? keys.indexOf(current) : -1;
          if (index === -1) {
            index = direction > 0 ? -1 : 0;
          }
          const nextIndex = (index + direction + keys.length) % keys.length;
          const nextKey = keys[nextIndex];
          setRangeSelection(rangeType, nextKey);
          renderTripletexTables();
        };

        const pickInitialSelection = (rangeType) => {
          const availableKeys = getSortedRangeKeys(rangeType);
          const metaKeys = getSortedRangeKeys(rangeType, { includeMeta: true });
          const pickFromList = (list, targets) => targets.find((key) => key && list.includes(key));

          if (rangeType === 'month') {
            const preferred = [];
            if (tripletexContext?.monthKey) preferred.push(tripletexContext.monthKey);
            const anchorMonthKey = (tripletexContext?.anchorIso || '').slice(0, 7);
            if (anchorMonthKey) preferred.push(anchorMonthKey);
            const todayMonthKey = todayISO.slice(0, 7);
            preferred.push(todayMonthKey);

            const matchAvailable = pickFromList(availableKeys, preferred);
            if (matchAvailable) return matchAvailable;
            const matchMeta = pickFromList(metaKeys, preferred);
            if (matchMeta) return matchMeta;
          } else if (rangeType === 'week') {
            const info = getISOWeekInfo(tripletexContext?.anchorIso || activeDateISO || todayISO);
            const targets = [info?.key];
            const matchAvailable = pickFromList(availableKeys, targets);
            if (matchAvailable) return matchAvailable;
            const matchMeta = pickFromList(metaKeys, targets);
            if (matchMeta) return matchMeta;
          } else if (rangeType === 'day') {
            const anchor = sanitizeIso(tripletexContext?.anchorIso || activeDateISO || todayISO);
            if (anchor) return anchor;
            const targets = [todayISO];
            const matchAvailable = pickFromList(availableKeys, targets);
            if (matchAvailable) return matchAvailable;
            const matchMeta = pickFromList(metaKeys, targets);
            if (matchMeta) return matchMeta;
          }

          if (availableKeys.length) return availableKeys[availableKeys.length - 1];
          if (metaKeys.length) return metaKeys[metaKeys.length - 1];
          return null;
        };

        const applyMonthSelectionState = () => {
          if (!monthButtons.length) return;
          const dataset = reportsState.data.month;
          const available = dataset?.availableKeys || new Set();
          const activeKey = reportsState.selection.month;
          monthButtons.forEach((button) => {
            const monthPart = button.dataset.month;
            const year = tripletexContext.year || today.getFullYear();
            const periodKey = dataset?.keyByMonth?.get(monthPart) || `${year}-${monthPart}`;
            button.dataset.periodKey = periodKey;
            if (available.has(periodKey)) button.setAttribute('data-available', 'true');
            else button.removeAttribute('data-available');
            const isActive = Boolean(activeKey && activeKey === periodKey);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            if (isActive) button.setAttribute('data-active', 'true');
            else button.removeAttribute('data-active');
            const meta = dataset?.meta?.get(periodKey);
            if (meta?.hint) button.title = meta.hint;
            else button.removeAttribute('title');
            if (isActive) scrollIntoViewQuietly(button);
          });
          updateMonthRangeButton();
        };

        const ensureWeekButtonForKey = (key, meta) => {
          if (!weekGrid) return null;
          let button = weekGrid.querySelector(`[data-week-key="${key}"]`);
          if (button) return button;
          button = document.createElement('button');
          button.type = 'button';
          button.className = 'reports-week';
          button.dataset.weekKey = key;
          button.setAttribute('aria-pressed', 'false');
          const weekNumber = meta?.week || Number(String(key).split('-W')[1] || 0);
          button.textContent = weekNumber ? `Uke ${String(weekNumber).padStart(2, '0')}` : key;
          if (meta?.hint) button.title = meta.hint;
          weekGrid.appendChild(button);
          return button;
        };

        const updateWeekButtons = () => {
          if (!weekGrid) return;
          ensureWeekButtons();
          const dataset = reportsState.data.week;
          const available = dataset?.availableKeys || new Set();
          const metaMap = dataset?.meta || new Map();
          const activeKey = reportsState.selection.week;
          metaMap.forEach((meta, key) => {
            ensureWeekButtonForKey(key, meta);
          });
          const buttons = Array.from(weekGrid.querySelectorAll('.reports-week'));
          buttons.forEach((button) => {
            const key = button.dataset.weekKey;
            const meta = metaMap.get(key);
            if (meta?.label) button.textContent = meta.label.split('')[0].trim();
            if (meta?.hint) button.title = meta.hint;
            if (available.has(key)) button.setAttribute('data-available', 'true');
            else button.removeAttribute('data-available');
            const isActive = Boolean(activeKey && activeKey === key);
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            if (isActive) button.setAttribute('data-active', 'true');
            else button.removeAttribute('data-active');
            if (isActive) scrollIntoViewQuietly(button);
          });
        };

        const updateDayButtons = () => {
          if (!dayGrid) return;
          const dataset = reportsState.data.day;
          const keys = getSortedRangeKeys('day').slice().sort((a, b) => b.localeCompare(a));
          const activeKey = reportsState.selection.day;
          dayGrid.innerHTML = '';
          if (!dataset || !keys.length) {
            if (dayPanelInput) {
              dayPanelInput.value = reportsState.selection.day || '';
            }
            return;
          }
          keys.forEach((key) => {
            const meta = dataset.meta?.get(key);
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'reports-day';
            button.dataset.dayKey = key;
            const isActive = activeKey === key;
            button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
            if (isActive) button.dataset.active = 'true';
            else delete button.dataset.active;
            const label = meta?.label || formatFriendlyDate(key);
            const caption = meta?.hint && meta.hint !== label ? meta.hint : '';
            button.textContent = '';
            const labelSpan = document.createElement('span');
            labelSpan.textContent = label;
            button.appendChild(labelSpan);
            if (caption) {
              const hint = document.createElement('small');
              hint.textContent = caption;
              button.appendChild(hint);
            }
            dayGrid.appendChild(button);
            if (activeKey === key) scrollIntoViewQuietly(button);
          });
          if (dayPanelInput) {
            dayPanelInput.value = activeKey || '';
          }
        };

        const updateDayHint = () => {
          if (!dayHintEl) return;
          const dayKey = reportsState.selection.day;
          if (!dayKey) {
            dayHintEl.textContent = 'Velg en dag fra listen eller angi dato.';
            return;
          }
          const dateObj = parseIsoDate(dayKey);
          if (!dateObj) {
            dayHintEl.textContent = 'Velg en dag via datovelgeren i kortet.';
            return;
          }
          dayHintEl.textContent = `Valgt dag: ${dayLabelFmt.format(dateObj)}`;
        };

        const renderTripletexTables = () => {
          const range = reportsState.activeRange;
          const dataset = reportsState.data[range];
          if (!dataset) return;
          if (ensureSelectionValid(range)) {
            updateRangeButtonsState();
          }
          const selectionKey = reportsState.selection[range];
          if (range === 'day' && selectionKey) {
            updateSelectedDateUI(selectionKey, 'day');
          }
          products.forEach((product) => {
            const rowsSource = dataset.products[product.key]?.rows || [];
            const rows = selectionKey ? rowsSource.filter((row) => row.key === selectionKey) : rowsSource;
            setTable(product.key, rows);
            const monthLabelFromContext = tripletexContext?.monthKey ? formatMonthKeyLabel(tripletexContext.monthKey) : '';
            let statusText = dataset.summary.label;
            if (selectionKey) {
              const meta = dataset.meta.get(selectionKey);
              statusText = meta?.label || meta?.hint || statusText || selectionKey;
            } else if (range === 'month' && monthLabelFromContext) {
              statusText = monthLabelFromContext;
            }
            setStatus(product.key, statusText || '');
          });
          // Trigger live sales aggregate for Tripletex-card
          if (range === 'month' && tripletexContext?.from && tripletexContext?.to) {
            fetchLiveSalesAggregate(tripletexContext.from, tripletexContext.to);
          }
          if (range === 'month') applyMonthSelectionState();
          if (range === 'week') updateWeekButtons();
          if (range === 'day') {
            updateDayButtons();
            updateDayHint();
          }
        };

        const fetchTripletexRange = async (rangeType) => {
          if (reportsState.loading[rangeType]) return;
          tripletexContext = buildTripletexContext(activeDateISO, rangeType);
          const { from, to, year } = tripletexContext;
          reportsState.loading[rangeType] = true;
          if (reportsState.activeRange === rangeType) {
            setStatusAll('Henter ', 'muted');
          }
          try {
            const base = await resolveTripletexEndpoint();
            const url = new URL(base, window.location.origin);
            url.searchParams.set('from', from);
            url.searchParams.set('to', to);
            if (['month', 'week', 'day'].includes(rangeType)) {
              url.searchParams.set('group', rangeType);
            }
            accountsParam.forEach((entry) => url.searchParams.append('accounts', entry));
            const res = await fetch(url.toString(), { headers: { accept: 'application/json' } });
            const text = await res.text();
            let data = {};
            try { data = JSON.parse(text); } catch (_) {}
            if (!res.ok) {
              const message = data?.message || data?.error || res.statusText || text || 'Kunne ikke hente Tripletex-data';
              throw new Error(message);
            }
            const dataset = normalizeTripletexResponse(data, { rangeType, from, to, year });
            reportsState.data[rangeType] = dataset;
            reportsState.error[rangeType] = null;
            const shouldPick = !reportsState.selection[rangeType];
            if (shouldPick) {
              const initialKey = pickInitialSelection(rangeType);
              if (initialKey) setRangeSelection(rangeType, initialKey, { syncDateUI: rangeType === 'day' });
            }
            if (rangeType === 'month' && tripletexContext?.monthKey) {
              setRangeSelection('month', tripletexContext.monthKey);
            }
            ensureSelectionValid(rangeType);
            if (rangeType === 'month') applyMonthSelectionState();
            if (rangeType === 'week') updateWeekButtons();
            if (rangeType === 'day') {
              if (!reportsState.selection.day) {
                setRangeSelection('day', sanitizeIso(tripletexContext.anchorIso), { syncDateUI: reportsState.activeRange === 'day' });
              }
              updateDayButtons();
              updateDayHint();
            }
            if (reportsState.activeRange === rangeType) {
              renderTripletexTables();
            }
          } catch (error) {
            reportsState.error[rangeType] = error;
            if (rangeType === 'month') {
              const previewDataset = buildTripletexPreview(rangeType, { from, to, year });
              if (previewDataset) {
                reportsState.data[rangeType] = previewDataset;
                setRangeSelection('month', tripletexContext.monthKey || '2025-01');
                setStatusAll('Forhndsvisning (Tripletex)', 'muted');
                renderTripletexTables();
                reportsState.loading[rangeType] = false;
                return;
              }
            }
            if (reportsState.activeRange === rangeType) {
              products.forEach((product) => setTable(product.key, []));
              setStatusAll(String(error.message || error), 'error');
            }
          } finally {
            reportsState.loading[rangeType] = false;
          }
        };

        if (reportsToolbarEl) {
          reportsToolbarEl.querySelectorAll('[data-range]').forEach((button) => {
            button.addEventListener('click', () => {
              const range = button.dataset.range;
              if (!range) return;
              const panel = getRangePanel(range);
              const panelVisible = panel ? !panel.hidden : false;
              const isActive = reportsState.activeRange === range;

              if (range === 'month') {
                if (!isActive) {
                  reportsState.activeRange = range;
                  applyRangeVisibility(range);
                  updateReportsRangeLabel(activeDateISO, range);
                  setRangePanelsVisibility('month');
                  if (!reportsState.data[range] && !reportsState.loading[range]) {
                    fetchTripletexRange(range);
                  } else {
                    if (!reportsState.selection[range]) {
                      const initialKey = pickInitialSelection(range);
                    if (initialKey) setRangeSelection(range, initialKey, { syncDateUI: range === 'day' });
                    }
                    applyMonthSelectionState();
                    renderTripletexTables();
                  }
                  return;
                }
                if (!panelVisible) {
                  setRangePanelsVisibility('month');
                  if (!reportsState.data[range] && !reportsState.loading[range]) {
                    fetchTripletexRange(range);
                  } else {
                    applyMonthSelectionState();
                  }
                  return;
                }
                hideRangePanel('month');
                return;
              }

            if (range === 'week') {
              if (!isActive) {
                reportsState.activeRange = range;
                applyRangeVisibility(range);
                updateReportsRangeLabel(activeDateISO, range);
                ensureWeekButtons();
                setRangePanelsVisibility('week');
                if (!reportsState.data[range] && !reportsState.loading[range]) {
                  fetchTripletexRange(range);
                } else {
                  if (!reportsState.selection[range]) {
                    const initialKey = pickInitialSelection(range);
                    if (initialKey) setRangeSelection(range, initialKey, { syncDateUI: range === 'day' });
                  }
                  updateWeekButtons();
                  renderTripletexTables();
                }
                return;
              }
                if (!panelVisible) {
                  setRangePanelsVisibility('week');
                  return;
                }
                if (reportsState.loading[range]) return;
                if (!reportsState.data[range]) {
                  fetchTripletexRange(range);
                  return;
              }
              cycleRangeSelection(range);
              return;
            }

            if (range === 'day') {
              if (!isActive) {
                reportsState.activeRange = range;
                applyRangeVisibility(range);
                updateReportsRangeLabel(activeDateISO, range);
                const anchorDay = sanitizeIso(activeDateISO || dayPicker?.value || todayISO);
                if (anchorDay) setRangeSelection('day', anchorDay, { syncDateUI: true });
                setRangePanelsVisibility('day');
                if (!reportsState.data[range] && !reportsState.loading[range]) {
                  fetchTripletexRange(range);
                } else {
                  if (!reportsState.selection[range]) {
                    const initialKey = pickInitialSelection(range);
                    if (initialKey) setRangeSelection(range, initialKey, { syncDateUI: range === 'day' });
                  }
                  updateDayButtons();
                  renderTripletexTables();
                }
                return;
              }
              if (!panelVisible) {
                setRangePanelsVisibility('day');
                updateDayButtons();
                return;
              }
            hideRangePanel('day');
            return;
          }

          reportsState.activeRange = range;
          applyRangeVisibility(range);
          if (range === 'day') {
            const desiredDay = sanitizeIso(reportsState.selection.day || activeDateISO || todayISO);
            if (desiredDay) setRangeSelection('day', desiredDay, { syncDateUI: true });
          }
          setRangePanelsVisibility(null);
          if (!reportsState.data[range] && !reportsState.loading[range]) {
            fetchTripletexRange(range);
          } else {
              if (!reportsState.selection[range]) {
                  const initialKey = pickInitialSelection(range);
                  if (initialKey) setRangeSelection(range, initialKey);
                }
                renderTripletexTables();
              }
              updateRangeButtonsState();
            });
          });

          if (!reportsState.activeRange) {
            reportsState.activeRange = 'month';
            applyRangeVisibility('month');
            updateRangeButtonsState();
            fetchTripletexRange('month');
          }

          monthButtons.forEach((button) => {
            button.addEventListener('click', () => {
              const year = tripletexContext.year || today.getFullYear();
              const periodKey = button.dataset.periodKey || `${year}-${button.dataset.month}`;
              setRangeSelection('month', periodKey);
              renderTripletexTables();
              applyMonthSelectionState();
              hideRangePanel('month');
            });
          });

          if (weekGrid) {
            weekGrid.addEventListener('click', (event) => {
              const trigger = event.target.closest('.reports-week');
              if (!trigger || trigger.disabled) return;
              const key = trigger.dataset.weekKey;
              if (!key) return;
              const isActive = reportsState.selection.week === key;
              setRangeSelection('week', isActive ? null : key);
              renderTripletexTables();
              updateWeekButtons();
            });
          }

          if (dayGrid) {
            dayGrid.addEventListener('click', (event) => {
              const trigger = event.target.closest('.reports-day');
              if (!trigger) return;
              const key = trigger.dataset.dayKey;
              if (!key) return;
              setRangeSelection('day', key, { syncDateUI: true });
              updateDayButtons();
              renderTripletexTables();
              hideRangePanel('day');
            });
          }

          if (dayPanelInput) {
            dayPanelInput.addEventListener('change', () => {
              const value = sanitizeIso(dayPanelInput.value);
              if (!value) return;
              setRangeSelection('day', value, { syncDateUI: true });
              updateDayButtons();
              renderTripletexTables();
            });
          }

          if (dayPanelToday) {
            dayPanelToday.addEventListener('click', () => {
              setRangeSelection('day', todayISO, { syncDateUI: true });
              updateDayButtons();
              renderTripletexTables();
              hideRangePanel('day');
            });
          }

          document.addEventListener('click', (event) => {
            ['month', 'day'].forEach((range) => {
              const panel = getRangePanel(range);
              if (!panel || panel.hidden) return;
              const button = getRangeButton(range);
              if (panel.contains(event.target)) return;
              if (button && button.contains(event.target)) return;
              hideRangePanel(range);
            });
          });

          document.addEventListener('keydown', (event) => {
            if (event.key !== 'Escape') return;
            let handled = false;
            ['month', 'day'].forEach((range) => {
              if (handled) return;
              const panel = getRangePanel(range);
              if (!panel || panel.hidden) return;
              hideRangePanel(range);
              const button = getRangeButton(range);
              if (button) button.focus();
              handled = true;
            });
          });
        }

        if (dayPicker) {
          dayPicker.addEventListener('change', () => {
            const value = sanitizeIso(dayPicker.value);
            setRangeSelection('day', value, { syncDateUI: true });
            if (!reportsState.data.day && !reportsState.loading.day) {
              fetchTripletexRange('day');
            } else if (reportsState.activeRange === 'day') {
              renderTripletexTables();
            } else {
              updateDayHint();
            }
          });
        }

        if (reportsToolbarEl) {
          setRangePanelsVisibility(null);
        }
        handleActiveDateChange = (nextIso) => {
          const targetRange = reportsState.activeRange || 'month';
          const nextContext = buildTripletexContext(nextIso, targetRange);
          const changed = !tripletexContext
            || nextContext.year !== tripletexContext.year
            || nextContext.monthKey !== tripletexContext.monthKey
            || nextContext.to !== tripletexContext.to;
          tripletexContext = nextContext;
          if (!reportsToolbar) return;
          if (targetRange === 'month' && tripletexContext?.monthKey) {
            setRangeSelection('month', tripletexContext.monthKey);
          }
          updateReportsRangeLabel(nextIso, targetRange);
          if (changed) {
            resetTripletexState();
            setStatusAll('Henter ', 'muted');
            products.forEach((product) => setTable(product.key, []));
            fetchTripletexRange(targetRange);
            return;
          }
          if (reportsState.activeRange === 'month' && reportsState.data.month) {
            const desiredKey = pickInitialSelection('month');
            if (desiredKey) {
              setRangeSelection('month', desiredKey);
              renderTripletexTables();
            }
          }
        };
      }
      }

      const navMobileToggle = document.querySelector('.nav-actions .mobile-toggle');
      const navControls = document.querySelector('.nav-controls');
      const topBar = document.querySelector('.top-bar');
      const mobileThemeSwitch = document.querySelector('.mobile-theme-switch');
      if (navMobileToggle && navControls) {
        navMobileToggle.addEventListener('click', () => {
          const open = !navControls.classList.contains('open');
          navControls.classList.toggle('open', open);
          navMobileToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
          if (mobileThemeSwitch && dashMq.matches) mobileThemeSwitch.hidden = !open;
        });
        const dashMq = window.matchMedia('(max-width: 720px)');
        const resetDash = () => {
          if (!dashMq.matches) {
            navControls.classList.remove('open');
            navMobileToggle.setAttribute('aria-expanded', 'false');
            if (mobileThemeSwitch) mobileThemeSwitch.hidden = false;
          } else {
            if (mobileThemeSwitch) mobileThemeSwitch.hidden = !navControls.classList.contains('open');
          }
        };
        dashMq.addEventListener ? dashMq.addEventListener('change', resetDash) : dashMq.addListener(resetDash);
        resetDash();
      }

      const themeToggleInput = document.querySelector('#dash-theme-toggle');
      if (themeToggleInput) {
        const isDark = document.body.getAttribute('data-theme') !== 'light';
        themeToggleInput.checked = isDark;
        themeToggleInput.addEventListener('change', () => {
          const toDark = themeToggleInput.checked;
          document.body.setAttribute('data-theme', toDark ? 'dark' : 'light');
          if (mobileThemeSwitch) {
            const mobileInput = mobileThemeSwitch.querySelector('input');
            if (mobileInput) mobileInput.checked = toDark;
          }
        });
      }

      if (mobileThemeSwitch) {
        const mobileInput = mobileThemeSwitch.querySelector('input');
        if (mobileInput && themeToggleInput) {
          const syncMobileState = () => {
            mobileInput.checked = themeToggleInput.checked;
          };
          syncMobileState();
          mobileInput.addEventListener('change', () => {
            const toDark = mobileInput.checked;
            document.body.setAttribute('data-theme', toDark ? 'dark' : 'light');
            themeToggleInput.checked = toDark;
          });
          themeToggleInput.addEventListener('change', syncMobileState);
        }
      }

      const languageToggleGroup = document.querySelector('[data-language-toggle]');
      if (languageToggleGroup) {
        languageToggleGroup.addEventListener('click', (event) => {
          const trigger = event.target.closest('[data-lang]');
          if (!trigger) return;
          languageToggleGroup.querySelectorAll('[data-lang]').forEach((btn) => {
            btn.setAttribute('aria-pressed', btn === trigger ? 'true' : 'false');
          });
        });
      }

      if (topBar) {
        let lastScrollY = window.scrollY;
        let ticking = false;
        const threshold = 10;
        const handleScroll = () => {
          const currentY = window.scrollY;
          const delta = currentY - lastScrollY;
          if (Math.abs(delta) > threshold) {
            const shouldHide = currentY > lastScrollY && currentY > 48;
            topBar.dataset.hidden = shouldHide ? '1' : '0';
            lastScrollY = currentY;
          }
          ticking = false;
        };
        window.addEventListener('scroll', () => {
          if (!ticking) {
            window.requestAnimationFrame(handleScroll);
            ticking = true;
          }
        }, { passive: true });
      }

      const userMenu = document.querySelector('[data-menu]');
      if (userMenu) {
        const trigger = userMenu.querySelector('.user-menu__trigger');
        const panel = userMenu.querySelector('.user-menu__panel');
        const items = Array.from(userMenu.querySelectorAll('.user-menu__item'));

        const setOpen = (open) => {
          userMenu.classList.toggle('open', open);
          trigger.setAttribute('aria-expanded', String(open));
          panel.toggleAttribute('hidden', !open);
          if (open) {
            requestAnimationFrame(() => items[0]?.focus());
          }
        };

        trigger.addEventListener('click', (event) => {
          event.preventDefault();
          const open = !userMenu.classList.contains('open');
          setOpen(open);
        });

        trigger.addEventListener('keydown', (event) => {
          if (event.key === 'ArrowDown') {
            event.preventDefault();
            if (!userMenu.classList.contains('open')) {
              setOpen(true);
            } else {
              items[0]?.focus();
            }
          } else if (event.key === 'Escape') {
            setOpen(false);
            trigger.focus();
          }
        });

        items.forEach((item, index) => {
          item.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
              event.preventDefault();
              const direction = event.key === 'ArrowDown' ? 1 : -1;
              const nextIndex = (index + direction + items.length) % items.length;
              items[nextIndex].focus();
            } else if (event.key === 'Escape') {
              setOpen(false);
              trigger.focus();
            }
          });

          item.addEventListener('click', () => {
            setOpen(false);
            trigger.focus();
          });
        });

        document.addEventListener('click', (event) => {
          if (!userMenu.contains(event.target)) {
            setOpen(false);
          }
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && userMenu.classList.contains('open')) {
            setOpen(false);
            trigger.focus();
          }
        });
      }
    })();
  </script>
</body>
</html>
